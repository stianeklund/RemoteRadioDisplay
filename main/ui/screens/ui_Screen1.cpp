// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.2
// LVGL version: 8.3.6
// Project name: Sunton_SquareLine_Project

#include "../ui.h"
#include "../ui_scale.h"
#include <stdio.h> // For snprintf
#include <math.h> // For roundf

#include "radio/radio_subjects.h" // LVGL 9 native observer subjects
#include "cat_parser.h"
#include "../../uart.h" // For uart_write_message
#include "cat_shared_types.h" // Include the shared types
#include "hal/spi_types.h"
#include "uart.h"
#include "settings_storage.h"
#include "../components/ui_power_popup.h"
#include "cat_state.hpp" // For radio_get_ssb_filter_mode

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h" // For ESP_LOGI

// Static variables to track multi-state button modes
static int nr_mode = 0; // 0=OFF, 1=NR1, 2=NR2
static int nb_mode = 0; // 0=OFF, 1=NB1, 2=NB2, 3=NB3
static bool g_data_mode_active = false; // Track DATA mode status

// Helper functions to update button labels
static void update_nr_button_label() {
    if (!lv_obj_is_valid(ui_NrButtonLabel)) return;
    
    if (nr_mode == 0) {
        lv_label_set_text(ui_NrButtonLabel, "NR");
    } else {
        static char nr_text[8];
        snprintf(nr_text, sizeof(nr_text), "NR%d", nr_mode);
        lv_label_set_text(ui_NrButtonLabel, nr_text);
    }
}

static void update_nb_button_label() {
    if (!lv_obj_is_valid(ui_NbButtonLabel)) return;
    
    if (nb_mode == 0) {
        lv_label_set_text(ui_NbButtonLabel, "NB");
    } else {
        static char nb_text[8];
        snprintf(nb_text, sizeof(nb_text), "NB%d", nb_mode);
        lv_label_set_text(ui_NbButtonLabel, nb_text);
    }
}

// Global variable to track current filter state
static int current_filter = 1; // Default to Filter A (FL1)

static void update_filter_labels() {
    if (!lv_obj_is_valid(ui_IfFilterALabel) || !lv_obj_is_valid(ui_IfFilterBLabel)) return;

    // Hide both filter labels
    lv_obj_add_flag(ui_IfFilterALabel, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_flag(ui_IfFilterBLabel, LV_OBJ_FLAG_HIDDEN);
}

// Public function to update filter display based on CAT parser input
void ui_screen1_update_filter(int filter_value) {
    if (filter_value >= 1 && filter_value <= 2) {
        current_filter = filter_value;
        update_filter_labels();
    }
}

// Blues (variants on your primary 0x2095F6)
#define COLOR_ARGENTINIAN_BLUE   0x4DAAFF  // lighter, for hovers or highlights
#define COLOR_AZUL    0x006BB3  // darker, for pressed states

// Pink
#define COLOR_ORCHID_PINK 0xE667DE

// Aqua (RX status icon)
#define COLOR_AQUA_LIGHT     0x2DD6C7  // middle icon glow
#define COLOR_AQUA_DARK      0x1A8A6E  // pressed/active state

// Reds (match your peak/bad-SWR color 0xAC1717)
#define COLOR_RED_LIGHT    0xD93F3F  // for alerts
#define COLOR_RED_DARK     0x800E0E  // for pressed or peak

// Greens (for RX status 0x2B9B25)
#define COLOR_SUCCESS_GREEN      0x57C25F  // success messages
#define COLOR_PIGMENT_GREEN 0x09AE56
#define COLOR_EMERALD_GREEN 0x4BC97B
#define COLOR_MINT 0x46AD80
// Oranges (you use 0xFF8C00 in RIT/XIT “ON”)
#define COLOR_ORANGE       0xFF8C00  // accent/info
#define COLOR_ORANGE_DARK  0xCC7200  // pressed accents
#define COLOR_ORANGE_VIBRANT 0xF26419 // vibrant orange accent

// Yellows
#define COLOR_SELECTIVE_YELLOW 0xFFBC1F  // golden yellow accent

// Additional Blues
#define COLOR_BLUE_STEEL   0x33658A  // darker, desaturated blue
#define COLOR_BLUE_SKY     0x86BBD8  // light, slightly desaturated blue

// Neutrals
#define COLOR_BG_DARK      0x292831  // your panel background
#define COLOR_GUNMETAL     0x22323c
#define COLOR_BG_MEDIUM    0x363636 //0x444444  // off-state segments
#define COLOR_FG_DARK      0x334C5B
#define COLOR_BG_LIGHT     0x666666  // disabled buttons
#define COLOR_TEXT         0xFFFFFF  // primary text
#define COLOR_BORDER       0x000000  // outlines

// Additional Specific Colors
#define COLOR_BLUE_PRIMARY         0x2095F6  // Main theme blue
#define COLOR_BLUE_METER_S_UNITS   0x2884f6  //0x2081F6  // Blue for S-Meter S1-S9, SWR low, ALC normal
#define COLOR_RED_METER_HIGH       0xD6251F  // 0xFF0000  //0xAC1717  // Red for S-Meter +dB, SWR high, ALC high
#define COLOR_BLUE_VFO_A_CHECKED   0x1A92F7  // Specific blue for VFO A label when checked
#define COLOR_GREEN_RX_ACTIVE      0x2B9B25  // Green for RX label active state
#define COLOR_RED_TX_ACTIVE        0xD90202  // Red for TX label active state
#define COLOR_BG_DARK_GRAY_BUTTON  0x414141  // Dark gray for SplitButton default background

lv_obj_t *ui_Screen1;
lv_obj_t *ui_SignalPanel;
lv_obj_t *ui_SMeterSegmentsContainer; // Container for S-Meter segments
lv_obj_t *ui_SMeterSegments[30]; // Array for 30 S-Meter segments
lv_obj_t *ui_SMeterLabel;
lv_obj_t *ui_Switch1;
lv_obj_t *ui_SwrMeterLabel;
lv_obj_t *ui_SwrMeterSegmentsContainer; // Container for SWR segments
lv_obj_t *ui_SwrMeterSegments[30]; // Array for 30 SWR segments
// lv_obj_t *ui_SwrTextLabel; // Replaced by ui_SwrMeterLabelsContainer
lv_obj_t *ui_SMeterLabelsContainer; // Container for S-Meter tick labels
lv_obj_t *ui_SMeterTickLabels[8]; // Array for 8 S-Meter tick labels (now in ui_SMeterLabelsContainer)
lv_obj_t *ui_SwrMeterLabelsContainer; // NEW: Container for SWR tick labels
lv_obj_t *ui_SwrMeterTickLabels[5]; // NEW: Array for 5 SWR tick labels (removed "5")
lv_obj_t *ui_AlcMeterSegmentsContainer; // Container for ALC segments
lv_obj_t *ui_AlcMeterSegments[30]; // Array for 30 ALC segments
lv_obj_t *ui_AlcLabel;
lv_obj_t *ui_CompMeterSegmentsContainer; // Container for COMP segments
lv_obj_t *ui_CompMeterSegments[15]; // Array for 15 COMP segments (dual mode)
lv_obj_t *ui_CompLabel;
lv_obj_t *ui_AfGainBar;
lv_obj_t *ui_AfGainLabel;
lv_obj_t *ui_RfGainLabel;
lv_obj_t *ui_RfGainBar;
lv_obj_t *ui_VfoAValue;
lv_obj_t *ui_VfoAFreqContainer; // Container for segmented frequency display
lv_obj_t *ui_VfoAFreqMHz; // MHz segment (e.g., "14")
lv_obj_t *ui_VfoAFreqKHz; // kHz segment (e.g., "012")
lv_obj_t *ui_VfoAFreqHz; // Hz segment (e.g., "000")
lv_obj_t *ui_VfoAFreqDot1; // First period separator "."
lv_obj_t *ui_VfoAFreqDot2; // Second period separator "."
lv_obj_t *ui_ModeLabel;
lv_obj_t *ui_DataModeLabel;
lv_obj_t *ui_VfoBValue;
lv_obj_t *ui_VfoAButtonBackground;
lv_obj_t *ui_VfoALabel;
lv_obj_t *ui_VfoBButtonBackground;
lv_obj_t *ui_VfoBLabel;
lv_obj_t *ui_MemoryLabel;            // Shows "M" when in memory mode
lv_obj_t *ui_MemoryChannelLabel;     // Shows "M.CH XX" when in memory mode
lv_obj_t *ui_AntennaSelectContainer; // New container for antenna elements
lv_obj_t *ui_AntSymbolLabel; // This will be the button for the symbol
lv_obj_t *ui_AntNumIndicatorContainer; // Container for Ant1Label and Ant2Label
lv_obj_t *ui_Ant1Label;
lv_obj_t *ui_Ant2Label;
lv_obj_t *ui_UtcTime;
lv_obj_t *ui_PwrLabel;
// lv_obj_t *ui_PwrValueLabel; // Replaced by ui_PwrLabelsContainer and ui_PwrTickLabels
lv_obj_t *ui_PwrLabelsContainer; // NEW: Container for Power tick labels
lv_obj_t *ui_PwrTickLabels[5]; // NEW: Array for 5 Power tick labels
lv_obj_t *ui_IfFilter;
lv_obj_t *ui_IfFilterALabel;
lv_obj_t *ui_IfFilterBLabel;
lv_obj_t *ui_RxTxLabel;
lv_obj_t *ui_PreAmpButton;
lv_obj_t *ui_PreAmpButtonLabel;
lv_obj_t *ui_AttButton;
lv_obj_t *ui_AttButtonLabel;
lv_obj_t *ui_AtTuneButton;
lv_obj_t *ui_AtTuneButtonLabel;
lv_obj_t *ui_ProcButton;
lv_obj_t *ui_ProcButtonLabel;
lv_obj_t *ui_IncreaseSwrButton;
lv_obj_t *ui_IncreaseSwrLabel;
lv_obj_t *ui_DecreaseSwrButton;
lv_obj_t *ui_DecreaseSwrLabel;
lv_obj_t *ui_IncreaseSMeterButton;
lv_obj_t *ui_IncreaseSMeterLabel;
lv_obj_t *ui_DecreaseSMeterButton;
lv_obj_t *ui_DecreaseSMeterLabel;
lv_obj_t *ui_SplitButton;
lv_obj_t *ui_SplitButtonLabel;
lv_obj_t *ui_LeftButtonColumn; // New container for left-side buttons
lv_obj_t *ui_NrButton;
lv_obj_t *ui_NrButtonLabel;
lv_obj_t *ui_AgcLabel;
lv_obj_t *ui_NotchLabel;
lv_obj_t *ui_XvtrLabel;
lv_obj_t *ui_RitContainer;
lv_obj_t *ui_RitLabel;
lv_obj_t *ui_RitValue;
lv_obj_t *ui_XitContainer;
lv_obj_t *ui_XitLabel;
lv_obj_t *ui_XitValue;
lv_obj_t *ui_NbButton;
lv_obj_t *ui_NbButtonLabel;
lv_obj_t *ui_DebugMode;
lv_obj_t *ui_DebugModeButtonLabel;
lv_obj_t *ui_SettingsButton;
lv_obj_t *ui_SettingsButtonLabel;
lv_obj_t *ui_CatConnectedButton;
// Filter Hi / Lo
lv_obj_t *ui_FilterUsbContainer;
lv_obj_t *ui_FilterUsb; // Filter type for USB / LSB etc
lv_obj_t *ui_FilterGlyph; // Gfx for filter
lv_obj_t *ui_High; // High cut off value, e.g 2400 Hz
lv_obj_t *ui_Low; // Low cut off value, e.g 100 Hz
lv_obj_t *ui_CwFilterWidth; // For CW mode, this is the filter width
lv_obj_t *ui_CwFilterModeGlyph; // For CW mode, this is the mode glyph (e.g., "B")
lv_obj_t *ui_CwFilterContainer;
lv_obj_t *ui_CatConnectedLabel;
lv_obj_t *ui_PsStatusLabel;

// Color arrays for meters - declared globally, initialized in ui_Screen1_screen_init
static lv_color_t s_meter_on_colors[30];
static lv_color_t swr_meter_on_colors[30];
static lv_color_t alc_meter_on_colors[30];
static lv_color_t comp_meter_on_colors[15]; // COMP meter uses 15 segments in dual mode
// static const lv_color_t PEAK_INDICATOR_COLOR = LV_COLOR_MAKE(0xFF, 0xFF, 0x00); // Removed: Yellow for peak

// Peak decay configuration
static uint32_t g_peak_decay_interval_ms = 100; // Peak hold duration in milliseconds (configurable)
static const int PEAK_DECAY_RATE = 1; // Segments per decay interval

// Meter update throttling - reduced frequency to minimize PSRAM bandwidth during display refresh
static const uint32_t METER_UPDATE_INTERVAL_MS = 30;  // 33Hz max (was 10ms/100Hz, caused jitter)
static const uint32_t VFO_UPDATE_THROTTLE_MS = 10;    // 100Hz max (was 5ms/200Hz)

// GLOBAL frequency string cache for ULTRA-FAST display updates (exposed to CAT parser)
bool g_freq_cache_initialized = false;
const char* g_khz_cache[1000]; // 000-999
const char* g_hz_cache[1000];  // 000-999  
const char* g_mhz_cache[1000]; // 0-999 MHz
static EXT_RAM_BSS_ATTR char g_khz_strings[1000][4];   // Storage for khz strings in SPIRAM
static EXT_RAM_BSS_ATTR char g_hz_strings[1000][4];    // Storage for hz strings in SPIRAM
static EXT_RAM_BSS_ATTR char g_mhz_strings[1000][4];   // Storage for MHz strings in SPIRAM

// CAT Connection Status
static const uint32_t CAT_INACTIVITY_TIMEOUT_MS = 190000; // 3 minutes and 10 seconds
static lv_timer_t *ui_cat_activity_check_timer = NULL; // New LVGL timer for UI-based check
static uint32_t ui_last_cat_activity_time = 0; // Timestamp of the last detected CAT activity

// Global state for peak hold
static bool g_peak_hold_enabled = false;
static bool g_split_mode_active = false; // Tracks if split mode is ON or OFF
static int g_current_vfo_function = -1; // Tracks current VFO function (0=A, 1=B, 2=Mem, -1=Unknown)
static bool s_tx_active = false; // Tracks last known TX state to clear meters on transition
static uint32_t s_tx_last_confirmed_time = 0; // Timestamp when TX was last confirmed by IF command
#define TX_STUCK_TIMEOUT_MS 30000 // 30s - only catch genuinely stuck states, normal TX can be 10+ seconds

// Cache latest VFO A/B frequencies for instant swap on VFO toggle
static uint32_t g_latest_vfo_a_freq = 0;
static uint32_t g_latest_vfo_b_freq = 0;

// Filter related static variables
static uint16_t s_current_high_cut_hz = 2700; // Example default high-cut for non-CW modes
static uint16_t s_current_low_cut_hz = 300;   // Example default low-cut for non-CW modes
static uint16_t s_current_cw_filter_width_hz = 500; // Default CW filter width (e.g., 500Hz)
int s_current_radio_mode = 2; // Example default mode (e.g., 2 for USB)

// ============================================================================
// Filter lookup tables from TS-590SG CAT Command Reference
// ============================================================================
// These tables map SH/SL index values to actual frequencies in Hz.
// The interpretation depends on the filter mode set via EX028/EX029:
//   Mode 0 (Hi/Lo Cut): SH = High-cut, SL = Low-cut
//   Mode 1 (Width/Shift): SH = Shift, SL = Width
// ============================================================================

// SSB/SSB-DATA/FM/FM-DATA mode High-cut frequency (Hz) - indices 0-13
// Used when EX028=0 (Hi/Lo Cut mode) for SSB, or EX029=0 for SSB-DATA
static const uint16_t high_cut_options[] = {
    1000, 1200, 1400, 1600, 1800, 2000,
    2200, 2400, 2600, 2800, 3000, 3400, 4000, 5000
}; // 14 values

// SSB/SSB-DATA/FM/FM mode Low-cut frequency (Hz) - indices 0-11
// Used when EX028=0 (Hi/Lo Cut mode) for SSB, or EX029=0 for SSB-DATA
static const uint16_t low_cut_options[] = {
    0, 50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000
}; // 12 values

// SSB/SSB-DATA mode Shift frequency (Hz) - indices 0-13 (TS-590SG)
// Used when EX028=1 (Width/Shift mode) for SSB, or EX029=1 for SSB-DATA
// SH command controls Shift in this mode
static const uint16_t shift_options[] = {
    1000, 1100, 1200, 1300, 1400, 1500,
    1600, 1700, 1750, 1800, 1900, 2000, 2100, 2210
}; // 14 values

// SSB/SSB-DATA mode Width (Hz) - indices 0-13
// Used when EX028=1 (Width/Shift mode) for SSB, or EX029=1 for SSB-DATA
// SL command controls Width in this mode
static const uint16_t width_options[] = {
    50, 80, 100, 150, 200, 250, 300, 400, 500, 600, 1000, 1500, 2000, 2500
}; // 14 values

// AM/AM-DATA mode High-cut frequency (Hz) - indices 0-3
static const uint16_t am_high_cut_options[] = {
    2500, 3000, 4000, 5000
}; // 4 values

// AM/AM-DATA mode Low-cut frequency (Hz) - indices 0-3
static const uint16_t am_low_cut_options[] = {
    0, 100, 200, 300
}; // 4 values


static int s_meter_peak_value = 0; // Stores the peak value for S-meter/Power
static int s_meter_current_value = 0; // Stores the current live signal value
static uint32_t s_meter_peak_last_update_time = 0; // Timestamp when peak was last updated
static bool s_meter_averaging_enabled = true; // Default to enabled
static lv_timer_t *peak_decay_timer = NULL; // Timer for peak decay

// SWR and ALC meter smoothed display values for attack/decay envelope
static int swr_display_value = 0;  // Smoothed SWR meter value (fast attack, slow decay)
static int alc_display_value = 0;  // Smoothed ALC meter value (fast attack, slow decay)
static int comp_display_value = 0; // Smoothed COMP meter value (fast attack, slow decay)

// PROC (Speech Processor) status tracking
static bool s_proc_enabled = false; // Tracks PROC on/off state from PR command

// Meter layout mode
typedef enum {
    METER_LAYOUT_SINGLE_ALC,    // Normal: 30 segments ALC (7px wide)
    METER_LAYOUT_DUAL_ALC_COMP  // TX+PROC: 15 seg ALC + 15 seg COMP (4px wide each)
} meter_layout_mode_t;

// Timestamp of last meter layout mode switch (for debouncing stale updates)
static uint32_t s_meter_mode_switch_time = 0;
static const uint32_t METER_MODE_SWITCH_DEBOUNCE_MS = 150; // Ignore updates for 150ms after mode switch

static meter_layout_mode_t s_current_meter_layout = METER_LAYOUT_SINGLE_ALC;

// REVOLUTIONARY S-meter state tracking for delta-only updates
static int s_meter_prev_state[30] = {0}; // Track previous state of each segment in internal RAM
static int s_meter_prev_current = -1;    // Previous current segments count
static int s_meter_prev_peak = -1;       // Previous peak segments count
static bool s_meter_prev_peak_enabled = false; // Previous peak hold state

// SWR/ALC meter state tracking for reliable delta-only updates (mirrors S-meter approach)
static int swr_meter_prev_state[30] = {0};  // Track previous state of each SWR segment
static int swr_meter_prev_current = -1;     // Previous SWR segments count
static int alc_meter_prev_state[30] = {0};  // Track previous state of each ALC segment
static int alc_meter_prev_current = -1;     // Previous ALC segments count
// static lv_obj_t *s_meter_peak_indicator = NULL; // Removed: Single visual peak indicator object

// Power meter rescaling: Track maximum SM value observed during TX to handle radios that
// don't reach SM=30 at full power (TS-590SG firmware quirk)
static int max_sm_tx_value = 30;  // Default to 30; gets updated to actual max observed

// Forward declarations for peak indicator functions
// static void create_peak_indicator(lv_obj_t *parent_container); // Removed
// static void update_peak_indicator(lv_obj_t *segments_array[], int peak_segment_index); // Removed

static void update_rxtx_label_status(bool is_transmitting);
static void reset_s_meter_state_tracking(void);
static void force_clear_s_meter_segments(void);
static void force_clear_swr_meter_segments(void);
static void force_clear_alc_meter_segments(void);
static void force_clear_all_meters(void);
static void switch_meter_layout_mode(meter_layout_mode_t new_mode);

// Helper function to convert CAT mode integer to display string
static const char* get_mode_string(int cat_mode) {
    switch (cat_mode) {
        case 1: return "LSB";
        case 2: return "USB";
        case 3:
        case 7: // CW-R maps to CW
            return "CW";
        case 4: return "FM";
        case 5: return "AM";
        case 6: // FSK
        case 9: // FSK-R
            return "FSK";
        case 10: // DATA-FM
        case 11: // DATA-LSB
        case 12: // DATA-USB
            return "DATA";
        default:
            return "---";
    }
}

// Initialize shared frequency string cache once
static void init_freq_cache(void) {
    if (!g_freq_cache_initialized) {
        for (int i = 0; i < 1000; i++) {
            snprintf(g_khz_strings[i], 4, "%03d", i);
            snprintf(g_hz_strings[i], 4, "%03d", i);
            snprintf(g_mhz_strings[i], 4, "%u", i); // No leading zeros for MHz
            g_khz_cache[i] = g_khz_strings[i];
            g_hz_cache[i] = g_hz_strings[i];
            g_mhz_cache[i] = g_mhz_strings[i];
        }
        g_freq_cache_initialized = true;
    }
}

// Extern function for CAT parser to initialize frequency cache
void init_freq_cache_extern(void) {
    init_freq_cache();
}

// Event callback for ui_Screen1 deletion to clean up resources
static void screen1_del_cb(lv_event_t *e)
{
    LV_UNUSED(e); // Target is ui_Screen1

    // Timer cleanup is now handled directly in ui_Screen1_screen_destroy()
    // before lv_obj_delete(ui_Screen1) is called.
    ESP_LOGI("UI_Screen1", "screen1_del_cb: Screen1 is being deleted.");
    // Add other global resource cleanups specific to Screen1 here if needed in the future
}

// Helper function to create and style meter segments
static void create_meter_segments(lv_obj_t *parent_container, lv_obj_t *segments_array[], int num_segments,
                                  lv_coord_t bar_width, lv_coord_t bar_height, const lv_color_t segment_on_colors[]) {
    for (int i = 0; i < num_segments; i++) {
        segments_array[i] = lv_bar_create(parent_container);
        lv_obj_set_size(segments_array[i], bar_width, bar_height);
        lv_bar_set_range(segments_array[i], 0, 1); // On/Off
        lv_bar_set_value(segments_array[i], 0, LV_ANIM_OFF); // Initial state: off

        lv_obj_set_style_radius(segments_array[i], 0, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_bg_color(segments_array[i], lv_color_hex(COLOR_BG_MEDIUM), LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_bg_opa(segments_array[i], 200, LV_PART_MAIN | LV_STATE_DEFAULT);

        lv_obj_set_style_radius(segments_array[i], 0, LV_PART_INDICATOR | LV_STATE_DEFAULT);
        lv_obj_set_style_bg_color(segments_array[i], segment_on_colors[i], LV_PART_INDICATOR | LV_STATE_DEFAULT);
        lv_obj_set_style_bg_opa(segments_array[i], 255, LV_PART_INDICATOR | LV_STATE_DEFAULT);
        lv_obj_set_style_anim_time(segments_array[i], 50, LV_PART_INDICATOR | LV_STATE_DEFAULT);
    }
}

// Helper function to update the display of a segmented meter
static void update_meter_display(
    lv_obj_t *segments_array[],
    int total_segments,
    int current_segments_to_light,
    bool is_peak_hold_enabled,
    int peak_segments_to_light,
    const lv_color_t base_on_colors[]
) {
    // Clamp values to be within [0, total_segments]
    current_segments_to_light = (current_segments_to_light < 0)
                                    ? 0
                                    : (current_segments_to_light > total_segments)
                                          ? total_segments
                                          : current_segments_to_light;
    peak_segments_to_light = (peak_segments_to_light < 0)
                                 ? 0
                                 : (peak_segments_to_light > total_segments)
                                       ? total_segments
                                       : peak_segments_to_light;

    // REVOLUTIONARY: Quick bailout if nothing changed for S-meter
    if (segments_array == ui_SMeterSegments) {
        if (s_meter_prev_current == current_segments_to_light &&
            s_meter_prev_peak == peak_segments_to_light &&
            s_meter_prev_peak_enabled == is_peak_hold_enabled) {
            return; // Nothing changed - ULTRA-FAST exit
        }
        
        // Update tracking variables
        s_meter_prev_current = current_segments_to_light;
        s_meter_prev_peak = peak_segments_to_light;
        s_meter_prev_peak_enabled = is_peak_hold_enabled;
    }

    // Calculate target states for all segments
    int target_states[total_segments];
    for (int i = 0; i < total_segments; i++) {
        target_states[i] = 0; // Default off
        
        if (segments_array == ui_SMeterSegments && is_peak_hold_enabled && 
            peak_segments_to_light > 0 && i == (peak_segments_to_light - 1) &&
            i >= current_segments_to_light) {
            // Peak segment for S-Meter with peak hold enabled
            // Only show peak dot if it's ABOVE the current live signal level
            target_states[i] = 1;
        } else if (i < current_segments_to_light) {
            // Part of current live value "bar"
            target_states[i] = 1;
        }
    }

    // Delta-only updates - only process changed segments
    // Use LV_ANIM_OFF for instant updates (animation causes multiple redraws per segment)
    if (segments_array == ui_SMeterSegments) {
        for (int i = 0; i < total_segments; i++) {
            if (segments_array[i] != NULL && lv_obj_is_valid(segments_array[i])) {
                // Compare against tracked state to skip redundant LVGL calls
                if (s_meter_prev_state[i] != target_states[i]) {
                    lv_bar_set_value(segments_array[i], target_states[i], LV_ANIM_OFF);
                    s_meter_prev_state[i] = target_states[i];
                }
            }
        }
    } else if (segments_array == ui_SwrMeterSegments) {
        // SWR meter - use explicit state tracking like S-meter
        if (swr_meter_prev_current == current_segments_to_light) {
            return; // Nothing changed - fast exit
        }
        swr_meter_prev_current = current_segments_to_light;

        for (int i = 0; i < total_segments; i++) {
            if (segments_array[i] != NULL && lv_obj_is_valid(segments_array[i])) {
                if (swr_meter_prev_state[i] != target_states[i]) {
                    lv_bar_set_value(segments_array[i], target_states[i], LV_ANIM_OFF);
                    swr_meter_prev_state[i] = target_states[i];
                }
            }
        }
    } else if (segments_array == ui_AlcMeterSegments) {
        // ALC meter - use explicit state tracking like S-meter
        if (alc_meter_prev_current == current_segments_to_light) {
            return; // Nothing changed - fast exit
        }
        alc_meter_prev_current = current_segments_to_light;

        for (int i = 0; i < total_segments; i++) {
            if (segments_array[i] != NULL && lv_obj_is_valid(segments_array[i])) {
                if (alc_meter_prev_state[i] != target_states[i]) {
                    lv_bar_set_value(segments_array[i], target_states[i], LV_ANIM_OFF);
                    alc_meter_prev_state[i] = target_states[i];
                }
            }
        }
    } else {
        // Generic fallback for unknown meters
        for (int i = 0; i < total_segments; i++) {
            if (segments_array[i] != NULL && lv_obj_is_valid(segments_array[i])) {
                lv_bar_set_value(segments_array[i], target_states[i], LV_ANIM_OFF);
            }
        }
    }
}

// Peak decay timer callback - automatically reduces peak over time
static void peak_decay_timer_cb(lv_timer_t *timer) {
    LV_UNUSED(timer);

    // When transmitting and PEP is enabled, decay the PEP peak too to avoid a stuck peak dot
    if (cat_get_transmit_status()) {
        pep_data_t *pep = pep_get_data();
        if (pep && pep->enabled) {
            uint32_t now = lv_tick_get();
            // Use UI-configured decay cadence
            if (pep->pep_power_raw > 0 && lv_tick_elaps(pep->pep_timestamp) >= g_peak_decay_interval_ms) {
                pep->pep_power_raw -= 1;
                if (pep->pep_power_raw < s_meter_current_value) pep->pep_power_raw = s_meter_current_value;
                if (pep->pep_power_raw < 0) pep->pep_power_raw = 0;
                pep->pep_power_watts = convert_raw_power_to_watts(pep->pep_power_raw);
                pep->pep_timestamp = now;

                // Refresh S-meter using PEP as the peak indicator during TX
                if (lv_obj_is_valid(ui_SMeterSegmentsContainer)) {
                    update_meter_display(ui_SMeterSegments, 30,
                                         s_meter_current_value,
                                         g_peak_hold_enabled,
                                         pep->pep_power_raw,
                                         s_meter_on_colors);
                }
                // No LV_MSG broadcast needed; UI already refreshed
            }
            return; // Don't run RX decay path while TX active
        }
    }

    // RX or PEP disabled: decay UI-held peak for S-meter
    if (!g_peak_hold_enabled || s_meter_peak_value <= 0) return;

    uint32_t current_time = lv_tick_get();
    uint32_t time_since_last_update = current_time - s_meter_peak_last_update_time;

    if (time_since_last_update >= g_peak_decay_interval_ms) {
        s_meter_peak_value -= PEAK_DECAY_RATE;
        if (s_meter_peak_value < s_meter_current_value) s_meter_peak_value = s_meter_current_value;
        if (s_meter_peak_value < 0) s_meter_peak_value = 0;

        s_meter_peak_last_update_time = current_time;

        if (lv_obj_is_valid(ui_SMeterSegmentsContainer)) {
            update_meter_display(ui_SMeterSegments, 30,
                                 s_meter_current_value,
                                 g_peak_hold_enabled,
                                 s_meter_peak_value,
                                 s_meter_on_colors);
        }
    }
}

static void update_filter_visibility_from_cat_mode(int mode);

// Track RIT/XIT state from RT/XT commands (separate from IF command)
static bool s_rit_enabled = false;
static bool s_xit_enabled = false;
static int s_rit_xit_offset = 0;  // Shared offset in Hz

// Core RIT status display update logic
static void update_rit_status_display(int rit_status) {
    s_rit_enabled = (rit_status != 0);
    ESP_LOGI("RIT_CB", "RIT status: %d, offset: %d", s_rit_enabled, s_rit_xit_offset);

    if (lv_obj_is_valid(ui_RitContainer)) {
        if (s_rit_enabled) {
            lv_obj_remove_flag(ui_RitContainer, LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_style_text_color(ui_RitLabel, lv_color_hex(COLOR_ORANGE_VIBRANT), LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_text_color(ui_RitValue, lv_color_hex(COLOR_ORANGE_VIBRANT), LV_PART_MAIN | LV_STATE_DEFAULT);
            static char buf[16];
            snprintf(buf, sizeof(buf), "%+.2f", (float) s_rit_xit_offset / 1000.0f);
            lv_label_set_text(ui_RitValue, buf);
        } else {
            lv_obj_add_flag(ui_RitContainer, LV_OBJ_FLAG_HIDDEN);
        }
    }
}

// LVGL 9 observer callback for RIT status updates
static void update_rit_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_rit_status_display(lv_subject_get_int(subject));
}

// Core XIT status display update logic
static void update_xit_status_display(int xit_status) {
    s_xit_enabled = (xit_status != 0);
    ESP_LOGI("XIT_CB", "XIT status: %d, offset: %d", s_xit_enabled, s_rit_xit_offset);

    if (lv_obj_is_valid(ui_XitContainer)) {
        if (s_xit_enabled) {
            lv_obj_remove_flag(ui_XitContainer, LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_style_text_color(ui_XitLabel, lv_color_hex(COLOR_ORANGE), LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_text_color(ui_XitValue, lv_color_hex(COLOR_ORANGE), LV_PART_MAIN | LV_STATE_DEFAULT);
            static char buf[16];
            snprintf(buf, sizeof(buf), "%+.2f", (float) s_rit_xit_offset / 1000.0f);
            lv_label_set_text(ui_XitValue, buf);
        } else {
            lv_obj_add_flag(ui_XitContainer, LV_OBJ_FLAG_HIDDEN);
        }
    }
}

// LVGL 9 observer callback for XIT status updates
static void update_xit_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_xit_status_display(lv_subject_get_int(subject));
}

// Core RIT/XIT frequency display update logic
static void update_rit_xit_freq_display(int freq) {
    s_rit_xit_offset = freq;
    ESP_LOGI("RIT_FREQ_CB", "RIT/XIT offset: %d Hz", s_rit_xit_offset);

    // Update displayed value if RIT is enabled
    if (s_rit_enabled && lv_obj_is_valid(ui_RitValue)) {
        static char buf[16];
        snprintf(buf, sizeof(buf), "%+.2f", (float) s_rit_xit_offset / 1000.0f);
        lv_label_set_text(ui_RitValue, buf);
    }
    // Update displayed value if XIT is enabled
    if (s_xit_enabled && lv_obj_is_valid(ui_XitValue)) {
        static char buf[16];
        snprintf(buf, sizeof(buf), "%+.2f", (float) s_rit_xit_offset / 1000.0f);
        lv_label_set_text(ui_XitValue, buf);
    }
}

// LVGL 9 observer callback for RIT/XIT frequency updates
static void update_rit_freq_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_rit_xit_freq_display(lv_subject_get_int(subject));
}

// Forward declarations
static void refresh_vfo_active_display();
static void format_memory_channel_text(char *buffer, size_t buffer_size, uint16_t channel);
static void update_memory_channel_display(const memory_channel_data_t *mem_data);

// Helper function to update display from IF data
static void update_if_data_display(const kenwood_if_data_t *if_data) {
    if (!if_data) {
        return;
    }

    // Debug: log RIT/XIT status from IF data
    static bool last_rit_logged = false;
    static bool last_xit_logged = false;
    if (if_data->rit_on != last_rit_logged || if_data->xit_on != last_xit_logged) {
        ESP_LOGI("IF_DATA_CB", "RIT=%d XIT=%d offset=%d", if_data->rit_on, if_data->xit_on, if_data->rit_xit_frequency);
        last_rit_logged = if_data->rit_on;
        last_xit_logged = if_data->xit_on;
    }

    // VFO A frequency: updated via radio_vfo_a_freq_subject observer
    // to ensure a single, transverter-aware source of truth.

    // --- RIT/XIT Status and Frequency Update from IF data ---
    // Sync local state variables with IF data (authoritative source)
    s_rit_enabled = if_data->rit_on;
    s_xit_enabled = if_data->xit_on;
    s_rit_xit_offset = if_data->rit_xit_frequency;

    static char rit_xit_buf[16];
    if (lv_obj_is_valid(ui_RitContainer)) {
        if (s_rit_enabled) {
            lv_obj_remove_flag(ui_RitContainer, LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_style_text_color(ui_RitLabel, lv_color_hex(COLOR_ORANGE_VIBRANT), LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_text_color(ui_RitValue, lv_color_hex(COLOR_ORANGE_VIBRANT), LV_PART_MAIN | LV_STATE_DEFAULT);
            snprintf(rit_xit_buf, sizeof(rit_xit_buf), "%+.2f", (float) s_rit_xit_offset / 1000.0f);
            lv_label_set_text(ui_RitValue, rit_xit_buf);
        } else {
            lv_obj_add_flag(ui_RitContainer, LV_OBJ_FLAG_HIDDEN);
        }
    }

    if (lv_obj_is_valid(ui_XitContainer)) {
        if (s_xit_enabled) {
            lv_obj_remove_flag(ui_XitContainer, LV_OBJ_FLAG_HIDDEN);
            lv_obj_set_style_text_color(ui_XitLabel, lv_color_hex(COLOR_ORANGE), LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_text_color(ui_XitValue, lv_color_hex(COLOR_ORANGE), LV_PART_MAIN | LV_STATE_DEFAULT);
            snprintf(rit_xit_buf, sizeof(rit_xit_buf), "%+.2f", (float) s_rit_xit_offset / 1000.0f);
            lv_label_set_text(ui_XitValue, rit_xit_buf);
        } else {
            lv_obj_add_flag(ui_XitContainer, LV_OBJ_FLAG_HIDDEN);
        }
    }

    // --- TX/RX Label Update ---
    // IF command is the authoritative source for TX/RX state - update timestamp
    s_tx_last_confirmed_time = lv_tick_get();

    // Only update UI when TX/RX state actually changes (avoids expensive S-meter clear on every IF)
    bool tx_state_changed = (s_tx_active != if_data->tx_rx);
    if (tx_state_changed) {
        if (s_tx_active && !if_data->tx_rx) {
            ESP_LOGI("UI_Screen1", "IF confirms RX while display showed TX - syncing state");
        }
        s_tx_active = if_data->tx_rx; // Sync with authoritative IF state

        if (lv_obj_is_valid(ui_RxTxLabel)) {
            update_rxtx_label_status(if_data->tx_rx);
        }
    }

    // --- Mode Label Update (only when mode changes) ---
    if (s_current_radio_mode != if_data->mode && lv_obj_is_valid(ui_ModeLabel)) {
        const char* mode_str = get_mode_string(if_data->mode);
        lv_label_set_text(ui_ModeLabel, mode_str);
    }

    // --- Split status tracking ---
    // Update global split status from IF data and refresh UI if changed
    if (g_split_mode_active != if_data->split_on) {
        g_split_mode_active = if_data->split_on;
        refresh_vfo_active_display();
    }

    // --- Memory Channel Label Update (when in memory mode) ---
    // Update M.CH label directly from IF data so it shows immediately
    if (if_data->function == 2 && if_data->memory_channel >= 0 && if_data->memory_channel <= 999) {
        if (lv_obj_is_valid(ui_MemoryChannelLabel)) {
            static int16_t s_last_displayed_channel = -1;
            if (if_data->memory_channel != s_last_displayed_channel) {
                char channel_text[16];
                format_memory_channel_text(channel_text, sizeof(channel_text), (uint16_t)if_data->memory_channel);
                lv_label_set_text(ui_MemoryChannelLabel, channel_text);
                s_last_displayed_channel = if_data->memory_channel;
            }
        }
    }

    // Only update filter visibility when mode actually changes (avoids UART spam)
    if (s_current_radio_mode != if_data->mode) {
        s_current_radio_mode = if_data->mode; // Store current mode
        update_filter_visibility_from_cat_mode(if_data->mode);
    }
}

// LVGL 9 observer callback for IF data updates
static void update_if_data_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    const kenwood_if_data_t *if_data = (const kenwood_if_data_t *)lv_subject_get_pointer(subject);
    update_if_data_display(if_data);
}

static void refresh_filter_display_for_current_mode(); // Forward declaration

// Legacy deferred screen change removed (Screen2 is pre-created)

// Helper function to update filter display based on CAT-style mode
static void update_filter_visibility_from_cat_mode(int cat_mode) {
    bool show_usb_filter = false;
    bool show_cw_filter = false;

    // Proactively refresh filter values for the new mode
    // Query SH/SL for SSB and DATA-SSB; FW for CW/FSK variants
    switch (cat_mode) {
        case 1: // LSB
        case 2: // USB
            uart_write_message("SH;");
            uart_write_message("SL;");
            uart_write_message("DA;"); // Query DATA mode status for proper filter selection
            break;
        case 11: // DATA-LSB
        case 12: // DATA-USB
            uart_write_message("SH;");
            uart_write_message("SL;");
            break;
        case 3: // CW
        case 7: // CW-R
        case 6: // FSK
        case 9: // FSK-R
            uart_write_message("FW;");
            break;
        default:
            break;
    }

    switch (cat_mode) {
        case 1: // LSB
        case 2: // USB
        case 4: // FM
        case 5: // AM
        case 11: // DATA-LSB (parsed from IF command's 'B')
        case 12: // DATA-USB (parsed from IF command's 'C')
            show_usb_filter = true;
            break;
        case 3: // CW
        case 7: // CW-R (map to CW)
        case 6: // FSK
        case 9: // FSK-R
            show_cw_filter = true;
            break;
        // For all other modes (including DATA variants 10) and unknown, both are hidden.
        default:
            break;
    }

    if (lv_obj_is_valid(ui_FilterUsbContainer)) {
        _ui_flag_modify(ui_FilterUsbContainer, LV_OBJ_FLAG_HIDDEN, show_usb_filter ? _UI_MODIFY_FLAG_REMOVE : _UI_MODIFY_FLAG_ADD);
        if (show_usb_filter && lv_obj_is_valid(ui_FilterGlyph)) {
            switch (cat_mode) {
                case 1: // LSB
                case 11: // DATA-LSB
                    lv_label_set_text(ui_FilterGlyph, "B");
                    break;
                case 2: // USB
                case 12: // DATA-USB
                    lv_label_set_text(ui_FilterGlyph, "C"); // Same glyph as LSB
                    break;
                case 3: // CW
                case 4: // FM
                case 5: // AM
                case 6: // FSK
                case 7: // CWR
                case 9: // FSKR
                    lv_label_set_text(ui_FilterGlyph, "D"); // Same glyph as CW
                    break;
                default:
                    // In case show_usb_filter is true for other modes in the future,
                    // ensure a default glyph or handle as needed.
                    // For now, covered by explicit cases.
                    break;
            }
        }
    }
    if (lv_obj_is_valid(ui_CwFilterContainer)) {
        _ui_flag_modify(ui_CwFilterContainer, LV_OBJ_FLAG_HIDDEN, show_cw_filter ? _UI_MODIFY_FLAG_REMOVE : _UI_MODIFY_FLAG_ADD);
    }
    refresh_filter_display_for_current_mode();
}

// Refreshes the VFO A/B active indicator based on g_current_vfo_function and g_split_mode_active
// g_current_vfo_function now represents the currently active VFO (RX when receiving, TX when transmitting)
// g_current_vfo_function: 0=VFO A, 1=VFO B, 2=Memory
static void refresh_vfo_active_display() {
    if (!lv_obj_is_valid(ui_VfoAButtonBackground) || !lv_obj_is_valid(ui_VfoBButtonBackground)) {
        return;
    }

    // State tracking to avoid unnecessary UI updates that cause jittering
    static bool s_last_memory_mode = false;
    static bool s_last_split_mode = false;
    static int s_last_vfo_highlight = -1;  // 0=A, 1=B, -1=none

    bool is_memory_mode = (g_current_vfo_function == 2);
    bool memory_mode_changed = (is_memory_mode != s_last_memory_mode);
    bool split_mode_changed = (g_split_mode_active != s_last_split_mode);

    // Determine which VFO to highlight (only relevant in VFO mode)
    int vfo_highlight = -1;
    if (!is_memory_mode) {
        if (g_current_vfo_function == 0) {
            vfo_highlight = 0;
        } else if (g_current_vfo_function == 1) {
            vfo_highlight = 1;
        }
    }
    bool vfo_highlight_changed = (vfo_highlight != s_last_vfo_highlight);

    // Only update UI if something actually changed
    if (!memory_mode_changed && !split_mode_changed && !vfo_highlight_changed) {
        return;
    }

    // Handle Memory mode display changes
    if (memory_mode_changed) {
        if (is_memory_mode) {
            // Entering memory mode - hide VFO A/B labels, show Memory labels
            if (lv_obj_is_valid(ui_VfoALabel)) {
                lv_obj_add_flag(ui_VfoALabel, LV_OBJ_FLAG_HIDDEN);
            }
            if (lv_obj_is_valid(ui_VfoBLabel)) {
                lv_obj_add_flag(ui_VfoBLabel, LV_OBJ_FLAG_HIDDEN);
            }
            if (lv_obj_is_valid(ui_MemoryLabel)) {
                lv_obj_add_state(ui_MemoryLabel, LV_STATE_CHECKED);
                lv_obj_remove_flag(ui_MemoryLabel, LV_OBJ_FLAG_HIDDEN);
            }
            if (lv_obj_is_valid(ui_MemoryChannelLabel)) {
                lv_obj_remove_flag(ui_MemoryChannelLabel, LV_OBJ_FLAG_HIDDEN);
            }
            if (lv_obj_is_valid(ui_VfoBValue)) {
                lv_obj_remove_flag(ui_VfoBValue, LV_OBJ_FLAG_HIDDEN);
                // Immediately show memory name (or placeholder) when entering memory mode
                // This clears the old VFO B frequency text
                memory_channel_data_t* mem_data = radio_get_memory_channel_buffer();
                ESP_LOGI("UI", "Entering memory mode: mem_data=%p, valid=%d",
                         mem_data, mem_data ? mem_data->valid : 0);
                if (mem_data && mem_data->valid) {
                    ESP_LOGI("UI", "Calling update_memory_channel_display with ch=%u name='%s'",
                             mem_data->channel, mem_data->name);
                    update_memory_channel_display(mem_data);
                } else {
                    // No valid memory data yet - show placeholder
                    ESP_LOGI("UI", "No valid memory data, showing placeholder");
                    lv_label_set_text(ui_VfoBValue, "---");
                }
            }
            // Hide VFO A/B backgrounds in memory mode
            if (lv_obj_is_valid(ui_VfoAButtonBackground)) {
                lv_obj_add_flag(ui_VfoAButtonBackground, LV_OBJ_FLAG_HIDDEN);
            }
            if (lv_obj_is_valid(ui_VfoBButtonBackground)) {
                lv_obj_add_flag(ui_VfoBButtonBackground, LV_OBJ_FLAG_HIDDEN);
            }
            // Hide split button in memory mode
            if (lv_obj_is_valid(ui_SplitButton)) {
                lv_obj_add_flag(ui_SplitButton, LV_OBJ_FLAG_HIDDEN);
            }
        } else {
            // Exiting memory mode - show VFO A/B labels, hide Memory labels
            if (lv_obj_is_valid(ui_VfoALabel)) {
                lv_obj_remove_flag(ui_VfoALabel, LV_OBJ_FLAG_HIDDEN);
            }
            if (lv_obj_is_valid(ui_VfoBLabel)) {
                lv_obj_remove_flag(ui_VfoBLabel, LV_OBJ_FLAG_HIDDEN);
            }
            if (lv_obj_is_valid(ui_MemoryLabel)) {
                lv_obj_remove_state(ui_MemoryLabel, LV_STATE_CHECKED);
                lv_obj_add_flag(ui_MemoryLabel, LV_OBJ_FLAG_HIDDEN);
            }
            if (lv_obj_is_valid(ui_MemoryChannelLabel)) {
                lv_obj_add_flag(ui_MemoryChannelLabel, LV_OBJ_FLAG_HIDDEN);
            }
        }
        s_last_memory_mode = is_memory_mode;
    }

    // Handle split mode and VFO highlight changes (only in VFO mode)
    if (!is_memory_mode && (split_mode_changed || vfo_highlight_changed || memory_mode_changed)) {
        if (g_split_mode_active) {
            if (lv_obj_is_valid(ui_SplitButton)) {
                lv_obj_add_state(ui_SplitButton, LV_STATE_CHECKED);
                lv_obj_remove_flag(ui_SplitButton, LV_OBJ_FLAG_HIDDEN);
            }
            if (lv_obj_is_valid(ui_VfoBValue)) {
                lv_obj_remove_flag(ui_VfoBValue, LV_OBJ_FLAG_HIDDEN);
            }
        } else {
            if (lv_obj_is_valid(ui_SplitButton)) {
                lv_obj_remove_state(ui_SplitButton, LV_STATE_CHECKED);
                lv_obj_add_flag(ui_SplitButton, LV_OBJ_FLAG_HIDDEN);
            }
            if (lv_obj_is_valid(ui_VfoBValue)) {
                lv_obj_add_flag(ui_VfoBValue, LV_OBJ_FLAG_HIDDEN);
            }
        }
        s_last_split_mode = g_split_mode_active;

        // Update VFO backgrounds
        if (lv_obj_is_valid(ui_VfoAButtonBackground)) {
            if (vfo_highlight == 0) {
                lv_obj_remove_flag(ui_VfoAButtonBackground, LV_OBJ_FLAG_HIDDEN);
            } else {
                lv_obj_add_flag(ui_VfoAButtonBackground, LV_OBJ_FLAG_HIDDEN);
            }
        }
        if (lv_obj_is_valid(ui_VfoBButtonBackground)) {
            if (vfo_highlight == 1) {
                lv_obj_remove_flag(ui_VfoBButtonBackground, LV_OBJ_FLAG_HIDDEN);
            } else {
                lv_obj_add_flag(ui_VfoBButtonBackground, LV_OBJ_FLAG_HIDDEN);
            }
        }
        s_last_vfo_highlight = vfo_highlight;
    }
}

// Core Split status display update logic
static void update_split_status_display(int split_status) {
    bool new_split_status = (split_status != 0);

    if (g_split_mode_active != new_split_status) {
        g_split_mode_active = new_split_status;
        refresh_vfo_active_display(); // Refresh display if split status changed
    }
}

// LVGL 9 observer callback for Split status updates
static void update_split_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_split_status_display(lv_subject_get_int(subject));
}


// Helper function to update VFO display from consolidated update
static void update_vfo_consolidated_display(const vfo_update_t *update) {
    if (!update) return;

    // Initialize shared frequency cache once
    init_freq_cache();

    // Static state for change detection
    static uint32_t s_prev_active_freq = 0xFFFFFFFF;
    static uint32_t s_prev_inactive_freq = 0xFFFFFFFF;
    static int8_t s_prev_active_vfo = -1;

    // ---- Update Active VFO Frequency (main display) ----
    if (update->active_freq != s_prev_active_freq) {
        static char mhz_buf[12];
        static uint32_t prev_mhz = 0xFFFFFFFF;
        static uint32_t prev_khz = 0xFFFFFFFF;
        static uint32_t prev_hz = 0xFFFFFFFF;

        uint32_t new_freq = update->active_freq;
        if (new_freq >= 30000 && new_freq <= 300000000) {
            if (lv_obj_is_valid(ui_VfoAFreqMHz) && lv_obj_is_valid(ui_VfoAFreqKHz) && lv_obj_is_valid(ui_VfoAFreqHz)) {
                uint32_t mhz_val = new_freq / 1000000;
                uint32_t khz_val = (new_freq % 1000000) / 1000;
                uint32_t hz_val = new_freq % 1000;

                if (mhz_val != prev_mhz) {
                    if (mhz_val < 1000) {
                        lv_label_set_text_static(ui_VfoAFreqMHz, g_mhz_cache[mhz_val]);
                    } else {
                        snprintf(mhz_buf, sizeof(mhz_buf), "%lu", mhz_val);
                        lv_label_set_text_static(ui_VfoAFreqMHz, mhz_buf);
                    }
                    prev_mhz = mhz_val;
                }
                if (khz_val != prev_khz && khz_val < 1000) {
                    lv_label_set_text_static(ui_VfoAFreqKHz, g_khz_cache[khz_val]);
                    prev_khz = khz_val;
                }
                if (hz_val != prev_hz && hz_val < 1000) {
                    lv_label_set_text_static(ui_VfoAFreqHz, g_hz_cache[hz_val]);
                    prev_hz = hz_val;
                }
            }
            s_prev_active_freq = new_freq;
        }
    }

    // ---- Update Inactive VFO Frequency (small label) ----
    // Skip this update when in memory mode - ui_VfoBValue shows memory name instead
    if (update->inactive_freq != s_prev_inactive_freq && g_current_vfo_function != 2) {
        static char inactive_buf[32];
        uint32_t new_freq = update->inactive_freq;

        if (new_freq >= 30000 && new_freq <= 300000000 && lv_obj_is_valid(ui_VfoBValue)) {
            uint32_t mhz_val = new_freq / 1000000;
            uint32_t khz_val = (new_freq % 1000000) / 1000;
            uint32_t hz_val = new_freq % 1000;

            snprintf(inactive_buf, sizeof(inactive_buf), "%lu.%03lu.%03lu", mhz_val, khz_val, hz_val);
            lv_label_set_text_static(ui_VfoBValue, inactive_buf);
            s_prev_inactive_freq = new_freq;
        }
    }

    // ---- Update VFO Function (A/B indicator) ----
    if (update->active_vfo != s_prev_active_vfo) {
        g_current_vfo_function = update->active_vfo;
        refresh_vfo_active_display();
        s_prev_active_vfo = update->active_vfo;
    }
}

// LVGL 9 observer callback for VFO consolidated updates
static void update_vfo_consolidated_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    const vfo_update_t *update = (const vfo_update_t *)lv_subject_get_pointer(subject);
    update_vfo_consolidated_display(update);
}

// Shared helper to update the top segmented frequency display from either VFO
// Set force=true to bypass throttle/equality checks (e.g., on VFO function toggle)
void set_top_segmented_frequency(uint32_t new_freq, bool force) {
    // Validate segmented UI objects exist
    if (!lv_obj_is_valid(ui_VfoAFreqContainer) || !lv_obj_is_valid(ui_VfoAFreqMHz) ||
        !lv_obj_is_valid(ui_VfoAFreqKHz) || !lv_obj_is_valid(ui_VfoAFreqHz)) {
        return;
    }

    static char mhz_buf[12];
    static uint32_t prev_mhz = 0xFFFFFFFF;
    static uint32_t prev_khz = 0xFFFFFFFF;
    static uint32_t prev_hz = 0xFFFFFFFF;
    static uint32_t displayed_freq = 0xFFFFFFFF;
    static uint32_t last_ui_update_time = 0;

    if (new_freq < 30000 || new_freq > 300000000) return;

    if (!force && new_freq == displayed_freq) return;
    if (!force && displayed_freq != 0xFFFFFFFF && abs((int32_t)new_freq - (int32_t)displayed_freq) < 5) return;

    uint32_t current_time = lv_tick_get();
    if (!force && lv_tick_elaps(last_ui_update_time) < VFO_UPDATE_THROTTLE_MS) return;

    uint32_t new_mhz = new_freq / 1000000;
    uint32_t new_khz = (new_freq % 1000000) / 1000;
    uint32_t new_actual_hz = new_freq % 1000;

    bool updated = false;
    bool mhz_valid = lv_obj_is_valid(ui_VfoAFreqMHz);
    bool khz_valid = lv_obj_is_valid(ui_VfoAFreqKHz);
    bool hz_valid = lv_obj_is_valid(ui_VfoAFreqHz);

    if (new_mhz != prev_mhz && mhz_valid && new_mhz < 1000) {
        lv_label_set_text_static(ui_VfoAFreqMHz, g_mhz_cache[new_mhz]);
        prev_mhz = new_mhz;
        updated = true;
    } else if (new_mhz != prev_mhz && mhz_valid && new_mhz >= 1000) {
        snprintf(mhz_buf, sizeof(mhz_buf), "%lu", new_mhz);
        lv_label_set_text_static(ui_VfoAFreqMHz, mhz_buf);
        prev_mhz = new_mhz;
        updated = true;
    }

    if (new_khz != prev_khz && new_khz < 1000 && khz_valid) {
        lv_label_set_text_static(ui_VfoAFreqKHz, g_khz_cache[new_khz]);
        prev_khz = new_khz;
        updated = true;
    }

    if (new_actual_hz != prev_hz && new_actual_hz < 1000 && hz_valid) {
        lv_label_set_text_static(ui_VfoAFreqHz, g_hz_cache[new_actual_hz]);
        prev_hz = new_actual_hz;
        updated = true;
    }

    if (updated || force) {
        displayed_freq = new_freq;
        last_ui_update_time = current_time;

        static uint32_t last_invalidation_time = 0;
        uint32_t time_since_last_invalidation = current_time - last_invalidation_time;
        bool major_change = (new_mhz != prev_mhz);
        if (force || (time_since_last_invalidation >= 10 || major_change)) {
            if (lv_obj_is_valid(ui_VfoAFreqContainer)) lv_obj_invalidate(ui_VfoAFreqContainer);
            last_invalidation_time = current_time;
        }
    }
}

// Core S-meter display update logic
static void update_s_meter_display(int sm_current_value) {
    // Ensure UI elements are initialized
    if (!lv_obj_is_valid(ui_SMeterSegmentsContainer) || !lv_obj_is_valid(ui_SwrMeterSegmentsContainer)) {
        return;
    }

    // High-performance exponential moving average for S-Meter
    static int s_meter_ema_scaled_obs = 0;
    static bool s_meter_ema_initialized_obs = false;

    int final_sm_value;
    bool is_tx_mode = cat_get_transmit_status();

    if (s_meter_averaging_enabled && !is_tx_mode) {
        if (!s_meter_ema_initialized_obs) {
            s_meter_ema_scaled_obs = sm_current_value << 8;
            s_meter_ema_initialized_obs = true;
        }
        s_meter_ema_scaled_obs = (sm_current_value * 224) + (s_meter_ema_scaled_obs >> 3);
        final_sm_value = s_meter_ema_scaled_obs >> 8;
    } else {
        final_sm_value = sm_current_value;
        s_meter_ema_initialized_obs = false;
    }

    s_meter_current_value = final_sm_value;

    // Power meter rescaling for TX mode
    if (is_tx_mode) {
        if (final_sm_value > max_sm_tx_value) {
            max_sm_tx_value = final_sm_value;
        }
        if (max_sm_tx_value > 0 && max_sm_tx_value < 30) {
            final_sm_value = (final_sm_value * 30) / max_sm_tx_value;
            if (final_sm_value > 30) final_sm_value = 30;
        }
    }

    // Peak hold logic
    if (g_peak_hold_enabled) {
        if (final_sm_value > s_meter_peak_value) {
            s_meter_peak_value = final_sm_value;
            s_meter_peak_last_update_time = lv_tick_get();
        } else if (s_meter_peak_value < final_sm_value) {
            s_meter_peak_value = final_sm_value;
            s_meter_peak_last_update_time = lv_tick_get();
        }
    } else {
        s_meter_peak_value = final_sm_value;
    }

    if (lv_obj_is_valid(ui_SMeterSegmentsContainer)) {
        int peak_value_to_use = s_meter_peak_value;
        if (cat_get_transmit_status()) {
            pep_data_t* pep_data = pep_get_data();
            if (pep_data && pep_data->enabled) {
                peak_value_to_use = pep_data->pep_power_raw;
            }
        }
        update_meter_display(ui_SMeterSegments, 30, final_sm_value, g_peak_hold_enabled, peak_value_to_use, s_meter_on_colors);
    }
}

// LVGL 9 observer callback for S-meter updates
static void update_s_meter_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_s_meter_display(lv_subject_get_int(subject));
}

// Core SWR meter display update logic (extracted for observer pattern)
static void update_swr_meter_display(int swr_new_value) {
    static uint32_t last_update_time_obs = 0;
    static bool had_swr_during_tx = false;  // Track if we've seen SWR > 0 during this TX

    if (lv_tick_elaps(last_update_time_obs) < METER_UPDATE_INTERVAL_MS) {
        return;
    }
    last_update_time_obs = lv_tick_get();

    if (!lv_obj_is_valid(ui_SwrMeterSegmentsContainer)) {
        return;
    }

    // Check TX status from subject
    bool is_transmitting = (lv_subject_get_int(&radio_tx_status_subject) != 0);

    // Reset tracking when not transmitting
    if (!is_transmitting) {
        had_swr_during_tx = false;
    }

    // Direct value - no smoothing for responsive SWR display
    swr_display_value = swr_new_value;

    if (is_transmitting && swr_new_value > 0) {
        had_swr_during_tx = true;
    }

    // During TX, if we've seen SWR and it drops to 0, keep showing 1 segment
    // This prevents flickering of the first segment during normal TX
    if (is_transmitting && had_swr_during_tx && swr_display_value == 0) {
        swr_display_value = 1;
    }

    if (lv_obj_is_valid(ui_SwrMeterSegmentsContainer)) {
        update_meter_display(ui_SwrMeterSegments, 30, swr_display_value, false, 0, swr_meter_on_colors);
    }
}

// LVGL 9 observer callback for SWR meter updates
static void update_swr_meter_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_swr_meter_display(lv_subject_get_int(subject));
}

void update_filter_visibility_from_dropdown_idx(uint16_t uint16);

// Core mode display update logic
static void update_mode_display(int cat_mode) {
    if (!lv_obj_is_valid(ui_ModeLabel)) {
        return;
    }

    // Update the mode label with the string representation
    const char* mode_str = get_mode_string(cat_mode);
    lv_label_set_text(ui_ModeLabel, mode_str);

    // Update s_current_radio_mode with the actual CAT mode received
    s_current_radio_mode = cat_mode;
    ESP_LOGD("UI_Screen1", "Mode Updated: CAT mode %d (%s)", cat_mode, mode_str);

    // Update filter visibility based on the actual CAT mode
    update_filter_visibility_from_cat_mode(cat_mode);
}

// LVGL 9 observer callback for mode updates
static void update_mode_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_mode_display(lv_subject_get_int(subject));
}

// Helper function to update filter display based on dropdown index
void update_filter_visibility_from_dropdown_idx(uint16_t dropdown_idx) {
    bool show_usb_filter = false;
    bool show_cw_filter = false;

    // Dropdown options: "USB\nLSB\nCW\nDATA\nFM\nAM"
    // Index 0: USB, 1: LSB, 2: CW, 3: DATA, 4: FM, 5: AM
    switch (dropdown_idx) {
        case 0: // USB
        case 1: // LSB
        case 4: // FM
        case 5: // AM
            show_usb_filter = true;
            break;
        case 2: // CW
            show_cw_filter = true;
            break;
        case 3: // DATA - User request implies hiding both for DATA
        default: // Unknown or unhandled index
            break;
    }

    if (lv_obj_is_valid(ui_FilterUsbContainer)) {
        _ui_flag_modify(ui_FilterUsbContainer, LV_OBJ_FLAG_HIDDEN, show_usb_filter ? _UI_MODIFY_FLAG_REMOVE : _UI_MODIFY_FLAG_ADD);
        if (show_usb_filter && lv_obj_is_valid(ui_FilterGlyph)) {
            // Dropdown options: "USB\nLSB\nCW\nDATA\nFM\nAM"
            // Index 0: USB, 1: LSB, 2: CW, 3: DATA, 4: FM, 5: AM
            switch (dropdown_idx) {
                case 1: // LSB
                    lv_label_set_text(ui_FilterGlyph, "C"); // Same as LSB in CAT mode
                    break;
                case 0: // USB
                    lv_label_set_text(ui_FilterGlyph, "C"); // Same as USB in CAT mode (corrected)
                    break;
                case 4: // FM
                case 5: // AM
                    lv_label_set_text(ui_FilterGlyph, "D"); // Same as FM/AM in CAT mode (corrected)
                    break;
                default:
                    // For DATA or other unhandled indices where show_usb_filter might be true.
                    // Currently, show_usb_filter is false for DATA.
                    break;
            }
        }
    }
    if (lv_obj_is_valid(ui_CwFilterContainer)) {
        _ui_flag_modify(ui_CwFilterContainer, LV_OBJ_FLAG_HIDDEN, show_cw_filter ? _UI_MODIFY_FLAG_REMOVE : _UI_MODIFY_FLAG_ADD);
    }
    refresh_filter_display_for_current_mode();
}

// Helper function to refresh the displayed filter values (High/Low or CW Width)
static void refresh_filter_display_for_current_mode() {
    static char buf[10]; // Buffer for formatting numbers

    // Check current mode
    bool is_cw_mode = (s_current_radio_mode == 3 || s_current_radio_mode == 7);

    ESP_LOGD("UI_Screen1", "refresh_filter_display: mode=%d, values: high=%u, low=%u, cw=%u",
             s_current_radio_mode, s_current_high_cut_hz, s_current_low_cut_hz, s_current_cw_filter_width_hz);

    if (is_cw_mode) {
        if (lv_obj_is_valid(ui_CwFilterWidth)) {
            snprintf(buf, sizeof(buf), "%u", s_current_cw_filter_width_hz);
            lv_label_set_text(ui_CwFilterWidth, buf);
        }
    } else { // USB, LSB, AM, FM, DATA modes
        if (lv_obj_is_valid(ui_High)) {
            snprintf(buf, sizeof(buf), "%u", s_current_high_cut_hz);
            lv_label_set_text(ui_High, buf);
        }
        if (lv_obj_is_valid(ui_Low)) {
            snprintf(buf, sizeof(buf), "%u", s_current_low_cut_hz);
            lv_label_set_text(ui_Low, buf);
        }
    }
}


// Core ALC meter display update logic (extracted for observer pattern)
static void update_alc_meter_display(int alc_new_value) {
    static uint32_t last_update_time_obs = 0;

    if (lv_tick_elaps(last_update_time_obs) < METER_UPDATE_INTERVAL_MS) {
        return;
    }
    last_update_time_obs = lv_tick_get();

    if (!lv_obj_is_valid(ui_AlcMeterSegmentsContainer)) {
        return;
    }

    // Debounce: ignore updates immediately after mode switch to prevent stale values
    if (lv_tick_elaps(s_meter_mode_switch_time) < METER_MODE_SWITCH_DEBOUNCE_MS) {
        return;
    }

    // Fast attack, slow decay for smooth meter behavior
    if (alc_new_value > alc_display_value) {
        alc_display_value = alc_new_value;
    } else {
        alc_display_value = (alc_display_value * 3 + alc_new_value) >> 2;
    }

    // In dual mode, map 30 dots to 15 segments (each segment = 2 dots)
    // In single mode, use full 30 segments
    int display_value = alc_display_value;
    int segment_count = 30;

    if (s_current_meter_layout == METER_LAYOUT_DUAL_ALC_COMP) {
        display_value = alc_display_value / 2; // Map 0-30 dots to 0-15 segments
        segment_count = 15;
    }

    if (lv_obj_is_valid(ui_AlcMeterSegmentsContainer)) {
        update_meter_display(ui_AlcMeterSegments, segment_count, display_value, false, 0, alc_meter_on_colors);
    }
}

// Core COMP meter display update logic (mirrors ALC meter pattern)
static void update_comp_meter_display(int comp_new_value) {
    static uint32_t last_update_time_comp = 0;

    if (lv_tick_elaps(last_update_time_comp) < METER_UPDATE_INTERVAL_MS) {
        return;
    }
    last_update_time_comp = lv_tick_get();

    // Only update COMP meter in dual mode
    if (s_current_meter_layout != METER_LAYOUT_DUAL_ALC_COMP) {
        return;
    }

    if (!lv_obj_is_valid(ui_CompMeterSegmentsContainer)) {
        return;
    }

    // Debounce: ignore updates immediately after mode switch to prevent stale values
    if (lv_tick_elaps(s_meter_mode_switch_time) < METER_MODE_SWITCH_DEBOUNCE_MS) {
        return;
    }

    // Fast attack, slow decay for smooth meter behavior
    if (comp_new_value > comp_display_value) {
        comp_display_value = comp_new_value;
    } else {
        comp_display_value = (comp_display_value * 3 + comp_new_value) >> 2;
    }

    // Map 0-30 dots from radio to 0-15 segments (each segment = 2 dots)
    int display_value = comp_display_value / 2;

    if (lv_obj_is_valid(ui_CompMeterSegmentsContainer)) {
        update_meter_display(ui_CompMeterSegments, 15, display_value, false, 0, comp_meter_on_colors);
    }
}

// LVGL 9 observer callback for ALC meter updates
static void update_alc_meter_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_alc_meter_display(lv_subject_get_int(subject));
}

// LVGL 9 observer callback for COMP meter updates
static void update_comp_meter_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_comp_meter_display(lv_subject_get_int(subject));
}

// Core AGC display update logic
static void update_agc_display(int agc_val) {
    if (!lv_obj_is_valid(ui_AgcLabel)) {
        return;
    }
    switch (agc_val) {
        case 0: // OFF
            lv_label_set_text(ui_AgcLabel, "AGC-O");
            break;
        case 1: // SLOW
            lv_label_set_text(ui_AgcLabel, "AGC-S");
            break;
        case 2: // FAST
            lv_label_set_text(ui_AgcLabel, "AGC-F");
            break;
        case 3: // Restore previous (no change while AGC already ON)
            break;
        default:
            lv_label_set_text(ui_AgcLabel, "AGC-?"); // Unknown or other state
            break;
    }
}

// LVGL 9 observer callback for AGC updates
static void update_agc_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_agc_display(lv_subject_get_int(subject));
}

// Core Notch display update logic
static void update_notch_display(int mode) {
    if (!lv_obj_is_valid(ui_NotchLabel)) {
        return;
    }
    switch ((notch_mode_t)mode) {
        case NOTCH_OFF:
            lv_obj_add_flag(ui_NotchLabel, LV_OBJ_FLAG_HIDDEN);
            break;
        case NOTCH_AUTO:
            lv_label_set_text(ui_NotchLabel, "NCH-A");
            lv_obj_remove_flag(ui_NotchLabel, LV_OBJ_FLAG_HIDDEN);
            break;
        case NOTCH_MANUAL_NORMAL:
            lv_label_set_text(ui_NotchLabel, "NCH-N");
            lv_obj_remove_flag(ui_NotchLabel, LV_OBJ_FLAG_HIDDEN);
            break;
        case NOTCH_MANUAL_WIDE:
            lv_label_set_text(ui_NotchLabel, "NCH-W");
            lv_obj_remove_flag(ui_NotchLabel, LV_OBJ_FLAG_HIDDEN);
            break;
    }
}

// LVGL 9 observer callback for Notch updates
static void update_notch_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_notch_display(lv_subject_get_int(subject));
}

// Core ATT display update logic
static void update_att_display(int att_status) {
    if (!lv_obj_is_valid(ui_AttButton)) {
        return;
    }
    bool att_on = (att_status == 1);
    if (att_on) {
        lv_obj_add_state(ui_AttButton, LV_STATE_CHECKED);
    } else {
        lv_obj_remove_state(ui_AttButton, LV_STATE_CHECKED);
    }
}

// LVGL 9 observer callback for ATT updates
static void update_att_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_att_display(lv_subject_get_int(subject));
}

// Core NB display update logic
static void update_nb_display(int mode) {
    if (!lv_obj_is_valid(ui_NbButton)) {
        return;
    }
    ESP_LOGI("UI_Screen1", "NB status callback: received mode=%d", mode);

    // Update global mode variable and button state
    nb_mode = mode;
    if (nb_mode == 0) {
        lv_obj_remove_state(ui_NbButton, LV_STATE_CHECKED);
    } else {
        lv_obj_add_state(ui_NbButton, LV_STATE_CHECKED);
    }

    // Update button label to show current mode
    update_nb_button_label();
}

// LVGL 9 observer callback for NB updates
static void update_nb_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_nb_display(lv_subject_get_int(subject));
}

// Core DATA mode display update logic
static void update_data_mode_display(int data_mode) {
    g_data_mode_active = (data_mode != 0);
    ESP_LOGI("UI_Screen1", "DATA mode status updated: %s", g_data_mode_active ? "ON" : "OFF");

    // Show or hide the DATA mode label based on status
    if (lv_obj_is_valid(ui_DataModeLabel)) {
        if (g_data_mode_active) {
            lv_obj_remove_flag(ui_DataModeLabel, LV_OBJ_FLAG_HIDDEN);
        } else {
            lv_obj_add_flag(ui_DataModeLabel, LV_OBJ_FLAG_HIDDEN);
        }
    }
}

// LVGL 9 observer callback for DATA mode updates
static void update_data_mode_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_data_mode_display(lv_subject_get_int(subject));
}

// Core NR display update logic
static void update_nr_display(int mode) {
    if (!lv_obj_is_valid(ui_NrButton)) {
        return;
    }

    // Update global mode variable and button state
    nr_mode = mode;
    if (nr_mode == 0) {
        lv_obj_remove_state(ui_NrButton, LV_STATE_CHECKED);
    } else {
        lv_obj_add_state(ui_NrButton, LV_STATE_CHECKED);
    }

    // Update button label to show current mode
    update_nr_button_label();
}

// LVGL 9 observer callback for NR updates
static void update_nr_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_nr_display(lv_subject_get_int(subject));
}

// Core Preamp display update logic
static void update_preamp_display(int preamp_val) {
    if (!lv_obj_is_valid(ui_PreAmpButton) || !lv_obj_is_valid(ui_PreAmpButtonLabel)) {
        return;
    }
    if (preamp_val == 0) {
        lv_obj_remove_state(ui_PreAmpButton, LV_STATE_CHECKED);
    }
    if (preamp_val == 1) {
        lv_obj_add_state(ui_PreAmpButton, LV_STATE_CHECKED);
    }
}

// LVGL 9 observer callback for Preamp updates
static void update_preamp_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_preamp_display(lv_subject_get_int(subject));
}

// Core Peak Hold status display update logic
static void update_peak_hold_status_display(bool enabled) {
    g_peak_hold_enabled = enabled;

    if (g_peak_hold_enabled) {
        // Peak hold is enabled, create timer if it doesn't exist
        if (peak_decay_timer == NULL) {
            peak_decay_timer = lv_timer_create(peak_decay_timer_cb, 100, NULL);
            if (peak_decay_timer) {
                lv_timer_set_repeat_count(peak_decay_timer, -1);
            } else {
                ESP_LOGE("UI_Screen1", "Failed to create peak_decay_timer");
            }
        }
    } else {
        // Peak hold is disabled
        s_meter_peak_value = 0;
        s_meter_current_value = 0;
        s_meter_peak_last_update_time = 0;
        reset_s_meter_state_tracking();

        if (peak_decay_timer != NULL) {
            lv_timer_del(peak_decay_timer);
            peak_decay_timer = NULL;
        }
    }
}

// LVGL 9 observer callback for Peak Hold status updates
static void update_peak_hold_status_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_peak_hold_status_display(lv_subject_get_int(subject) != 0);
}

// Core Peak Hold duration update logic
static void update_peak_hold_duration_display(uint32_t new_duration) {
    // Validate range (same as settings storage validation)
    if (new_duration >= 10 && new_duration <= 1000) {
        g_peak_decay_interval_ms = new_duration;
        ESP_LOGI("UI_Screen1", "Peak Hold duration updated to: %lu ms", g_peak_decay_interval_ms);
    } else {
        ESP_LOGW("UI_Screen1", "Invalid peak hold duration received: %lu ms", new_duration);
    }
}

// LVGL 9 observer callback for Peak Hold duration updates
static void update_peak_hold_duration_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_peak_hold_duration_display((uint32_t)lv_subject_get_int(subject));
}

// Core S-Meter Averaging update logic
static void update_smeter_averaging_display(bool new_averaging_state) {
    // If the state changed, reset S-meter tracking to prevent stuck segments
    if (s_meter_averaging_enabled != new_averaging_state) {
        reset_s_meter_state_tracking();
        ESP_LOGI("UI_Screen1", "S-meter state reset due to averaging toggle");
    }

    s_meter_averaging_enabled = new_averaging_state;
    ESP_LOGI("UI_Screen1", "S-Meter averaging %s", s_meter_averaging_enabled ? "enabled" : "disabled");
}

// LVGL 9 observer callback for S-Meter Averaging updates
static void update_smeter_averaging_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_smeter_averaging_display(lv_subject_get_int(subject) != 0);
}

// Core XVTR label visibility update logic
static void update_xvtr_label_visibility(void) {
    if (!lv_obj_is_valid(ui_XvtrLabel)) {
        return;
    }

    // Get EX056 transverter state from radio
    transverter_state_t* state = get_transverter_state();
    bool ex056_enabled = (state && state->ex056_data.valid && state->ex056_data.enabled);

    // Get UIXD transverter state from ARCI
    extern bool ui_get_transverter_enabled(void);
    bool uixd_enabled = ui_get_transverter_enabled();

    // Show XVTR label if EITHER EX056 OR UIXD is enabled
    if (ex056_enabled || uixd_enabled) {
        lv_obj_remove_flag(ui_XvtrLabel, LV_OBJ_FLAG_HIDDEN);
        ESP_LOGD("UI_Screen1", "XVTR label shown (EX056=%d, UIXD=%d)", ex056_enabled, uixd_enabled);
    } else {
        lv_obj_add_flag(ui_XvtrLabel, LV_OBJ_FLAG_HIDDEN);
        ESP_LOGD("UI_Screen1", "XVTR label hidden (EX056=%d, UIXD=%d)", ex056_enabled, uixd_enabled);
    }
}

// LVGL 9 observer callback for transverter state updates
static void update_transverter_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    LV_UNUSED(subject);

    ESP_LOGD("UI_Screen1", "Transverter state update received (observer)");
    update_xvtr_label_visibility();
    cat_request_transverter_display_refresh();
}

// LVGL 9 observer callback for transverter enabled (UIXD) updates
static void update_transverter_enabled_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    LV_UNUSED(subject);

    ESP_LOGD("UI_Screen1", "Transverter enabled (UIXD) update received");
    update_xvtr_label_visibility();
    cat_request_transverter_display_refresh();
}

// Core TX status display update logic
// Note: IF command is the authoritative source - this handles faster TX/RX notifications
static void update_tx_status_display(int tx_status) {
    if (!lv_obj_is_valid(ui_RxTxLabel)) {
        return;
    }
    bool new_tx_state = (tx_status != 0);

    // TX stuck protection: If transitioning TO TX, reset the confirmation timer
    // The IF command (polled every 100ms) will confirm this state
    if (new_tx_state && !s_tx_active) {
        s_tx_last_confirmed_time = lv_tick_get();
        ESP_LOGD("UI_Screen1", "TX command received - awaiting IF confirmation");
    }

    // Only update UI if TX state has actually changed to avoid clearing meters unnecessarily
    if (s_tx_active != new_tx_state) {
        update_rxtx_label_status(new_tx_state);

        // If we just transitioned away from TX, clear metering segments that require live telemetry
        if (s_tx_active && !new_tx_state) {
            // Use explicit force_clear functions for reliable segment clearing
            force_clear_swr_meter_segments();
            force_clear_alc_meter_segments();
            // Reset S-meter cached segment counts so the next reading draws correctly
            s_meter_prev_current = -1;
            s_meter_prev_peak = -1;
            s_meter_prev_peak_enabled = false;
        }
    }

    // Always update state tracker to prevent desync
    s_tx_active = new_tx_state;

    // In split mode, TX status change affects which VFO is active, so refresh VFO indicators
    if (g_split_mode_active) {
        refresh_vfo_active_display();
    }
}

// LVGL 9 observer callback for TX status updates
static void update_tx_status_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_tx_status_display(lv_subject_get_int(subject));
}

// Core AF gain display update logic
static void update_af_gain_display(int af_gain_value) {
    if (!lv_obj_is_valid(ui_AfGainBar)) {
        return;
    }

    ESP_LOGD("UI", "AF Gain value:%d", af_gain_value);

    // Ensure the value is within the bar's range (0-255)
    if (af_gain_value < 0) af_gain_value = 0;
    if (af_gain_value > 255) af_gain_value = 255;

    lv_bar_set_value(ui_AfGainBar, af_gain_value, LV_ANIM_ON);
}

// LVGL 9 observer callback for AF gain updates
static void update_af_gain_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_af_gain_display(lv_subject_get_int(subject));
}

// Core RF gain display update logic
static void update_rf_gain_display(int rf_gain_value) {
    if (!lv_obj_is_valid(ui_RfGainBar)) {
        return;
    }

    ESP_LOGD("UI", "RF Gain value:%d", rf_gain_value);

    // Ensure the value is within the bar's range (0-255)
    if (rf_gain_value < 0) rf_gain_value = 0;
    if (rf_gain_value > 255) rf_gain_value = 255;

    lv_bar_set_value(ui_RfGainBar, rf_gain_value, LV_ANIM_ON);
}

// LVGL 9 observer callback for RF gain updates
static void update_rf_gain_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_rf_gain_display(lv_subject_get_int(subject));
}

// Core Processor (PROC) status display update logic
static void update_proc_display(int proc_status) {
    if (!lv_obj_is_valid(ui_ProcButton)) {
        return;
    }

    bool proc_on = (proc_status != 0);
    bool state_changed = (s_proc_enabled != proc_on);
    s_proc_enabled = proc_on;

    // Update button visual state
    if (proc_on) {
        lv_obj_add_state(ui_ProcButton, LV_STATE_CHECKED);
    } else {
        lv_obj_remove_state(ui_ProcButton, LV_STATE_CHECKED);
    }

    // Check if we need to switch meter layout mode
    // Dual mode: TX + PROC both enabled
    // Single mode: RX or PROC disabled
    if (state_changed) {
        meter_layout_mode_t target_mode = METER_LAYOUT_SINGLE_ALC;

        if (s_tx_active && s_proc_enabled) {
            target_mode = METER_LAYOUT_DUAL_ALC_COMP;
        }

        if (s_current_meter_layout != target_mode) {
            ESP_LOGI("PROC_UPDATE", "PROC=%d TX=%d -> switching to %s mode",
                     s_proc_enabled, s_tx_active,
                     (target_mode == METER_LAYOUT_DUAL_ALC_COMP) ? "DUAL" : "SINGLE");
            switch_meter_layout_mode(target_mode);
        }
    }
}

// LVGL 9 observer callback for Processor status updates
static void update_proc_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_proc_display(lv_subject_get_int(subject));
}

// ui_at_status_t is now defined in cat_shared_types.h

// Core Antenna Select display update logic
static void update_antenna_select_display(int antenna_select) {
    if (!lv_obj_is_valid(ui_Ant1Label) || !lv_obj_is_valid(ui_Ant2Label)) {
        return;
    }

    // CAT parser sends 0=ANT1, 1=ANT2
    if (antenna_select == 0) {
        lv_label_set_text(ui_Ant1Label, "1");
        lv_obj_remove_flag(ui_Ant1Label, LV_OBJ_FLAG_HIDDEN);
        lv_obj_add_flag(ui_Ant2Label, LV_OBJ_FLAG_HIDDEN);
    } else if (antenna_select == 1) {
        lv_label_set_text(ui_Ant2Label, "2");
        lv_obj_remove_flag(ui_Ant2Label, LV_OBJ_FLAG_HIDDEN);
        lv_obj_add_flag(ui_Ant1Label, LV_OBJ_FLAG_HIDDEN);
    }
}

// LVGL 9 observer callback for Antenna Select updates
static void update_antenna_select_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_antenna_select_display(lv_subject_get_int(subject));
}

// Helper function to format memory channel number according to TS-590SG conventions
// Channels 0-99: "M.CH 00" to "M.CH 99"
// Channels 100-109: "M.CH P00" to "M.CH P09" (Program Memory)
// Channels 110-119: "M.CH E00" to "M.CH E09" (Emergency Memory)
// Channels 120-299: "M.CH 120" to "M.CH 299"
static void format_memory_channel_text(char *buffer, size_t buffer_size, uint16_t channel) {
    if (channel >= 100 && channel <= 109) {
        // Program Memory: P00-P09
        snprintf(buffer, buffer_size, "M.CH P%02d", channel - 100);
    } else if (channel >= 110 && channel <= 119) {
        // Emergency Memory: E00-E09
        snprintf(buffer, buffer_size, "M.CH E%02d", channel - 110);
    } else if (channel < 100) {
        // Standard channels: 00-99
        snprintf(buffer, buffer_size, "M.CH %02d", channel);
    } else {
        // Extended channels: 120-299
        snprintf(buffer, buffer_size, "M.CH %d", channel);
    }
}

// Core Memory Channel display update logic
static void update_memory_channel_display(const memory_channel_data_t *mem_data) {
    if (!mem_data || !mem_data->valid) {
        ESP_LOGW("UI", "update_memory_channel_display: mem_data invalid (ptr=%p, valid=%d)",
                 mem_data, mem_data ? mem_data->valid : 0);
        return;
    }

    ESP_LOGI("UI", "update_memory_channel_display: ch=%u name='%s'",
             mem_data->channel, mem_data->name);

    // Update Memory channel label (e.g., "M.CH 15", "M.CH P05", "M.CH E07")
    if (lv_obj_is_valid(ui_MemoryChannelLabel)) {
        char channel_text[16];
        format_memory_channel_text(channel_text, sizeof(channel_text), mem_data->channel);
        lv_label_set_text(ui_MemoryChannelLabel, channel_text);
    }

    // Update VFO B value area with memory channel name
    // Note: This function is only called when in memory mode, so we don't need to check g_current_vfo_function
    if (lv_obj_is_valid(ui_VfoBValue)) {
        // Display memory name if non-empty, otherwise show channel number with proper formatting
        if (mem_data->name[0] != '\0') {
            ESP_LOGI("UI", "Setting memory name: '%s'", mem_data->name);
            lv_label_set_text(ui_VfoBValue, mem_data->name);
        } else {
            char name_text[16];
            // Use same formatting convention as M.CH label (P00-P09, E00-E09)
            if (mem_data->channel >= 100 && mem_data->channel <= 109) {
                snprintf(name_text, sizeof(name_text), "P%02d", mem_data->channel - 100);
            } else if (mem_data->channel >= 110 && mem_data->channel <= 119) {
                snprintf(name_text, sizeof(name_text), "E%02d", mem_data->channel - 110);
            } else {
                snprintf(name_text, sizeof(name_text), "CH %03d", mem_data->channel);
            }
            ESP_LOGI("UI", "Setting fallback channel: '%s'", name_text);
            lv_label_set_text(ui_VfoBValue, name_text);
        }
    }
}

// LVGL 9 observer callback for Memory Channel updates
static void update_memory_channel_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    const memory_channel_data_t *mem_data = (const memory_channel_data_t *)lv_subject_get_pointer(subject);
    update_memory_channel_display(mem_data);
}

// Helper function to update AT status display
// AT status bitmask: bit0=rx_at_in, bit1=tx_at_in, bit2=tuning_in_progress
static void update_at_status_display(bool rx_at_in, bool tx_at_in, bool tuning_in_progress) {
    if (!lv_obj_is_valid(ui_AtTuneButton) || !lv_obj_is_valid(ui_AtTuneButtonLabel)) {
        return; // Early exit if UI elements don't exist or are invalid
    }

    if (tuning_in_progress) {
        // lv_label_set_text(ui_AtTuneButtonLabel, "AT>TX");
        // While tuning, button is typically not "checked" as "IN" but visually indicates activity.
        // For now, we ensure it's not showing "AT IN" state.
        // You might want a specific style for "TUNING" (e.g., different color, blinking)
        // which would be applied here.
        lv_obj_remove_state(ui_AtTuneButton, LV_STATE_CHECKED);
        // Example: Add a temporary "tuning" style if you have one defined
        // lv_obj_add_state(ui_AtTuneButton, LV_STATE_USER_1); // Assuming LV_STATE_USER_1 is for tuning
    } else {
        // Example: Clear temporary "tuning" style if used
        // lv_obj_remove_state(ui_AtTuneButton, LV_STATE_USER_1);

        // TODO reconsider this
        if (lv_obj_is_valid(ui_AtTuneButton)) { // Ensure button is valid before changing state
            if (rx_at_in) {
                // lv_label_set_text(ui_AtTuneButtonLabel, "RX<AT>");
                lv_obj_add_state(ui_AtTuneButton, LV_STATE_CHECKED);
            }

            if (rx_at_in || tx_at_in) {
                if (rx_at_in && tx_at_in) {
                    // lv_label_set_text(ui_AtTuneButtonLabel, "RX<AT>TX");
                    lv_obj_add_state(ui_AtTuneButton, LV_STATE_CHECKED);
                } else if (rx_at_in && !tx_at_in) {
                    //lv_label_set_text(ui_AtTuneButtonLabel, "RX<AT>");
                    lv_obj_add_state(ui_AtTuneButton, LV_STATE_CHECKED);
                } else if (!rx_at_in && tx_at_in) {
                    // lv_label_set_text(ui_AtTuneButtonLabel, "AT>TX");
                    lv_obj_add_state(ui_AtTuneButton, LV_STATE_CHECKED);
                } else { // This 'else' branch is logically unreachable given the preceding conditions.
                    if (lv_obj_is_valid(ui_AtTuneButtonLabel)) {
                        //lv_label_set_text(ui_AtTuneButtonLabel, "AT");
                        lv_obj_remove_state(ui_AtTuneButton, LV_STATE_DEFAULT);
                    }
                    // lv_label_set_text(ui_AtTuneButtonLabel, "AT"); // Original comment
                    lv_obj_remove_state(ui_AtTuneButton, LV_STATE_DEFAULT);
                }
            } else { // Neither rx_at_in nor tx_at_in is true
                 lv_obj_remove_state(ui_AtTuneButton, LV_STATE_CHECKED); // Clear the checked state
                 if (lv_obj_is_valid(ui_AtTuneButtonLabel)) {
                    //lv_label_set_text(ui_AtTuneButtonLabel, "AT"); // Optionally reset label text
                 }
            }
        }
    }
}

// LVGL 9 observer callback for AT status updates
// AT status bitmask: bit0=rx_at_in, bit1=tx_at_in, bit2=tuning_in_progress
static void update_at_status_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    int32_t bitmask = lv_subject_get_int(subject);
    update_at_status_display((bitmask & 0x01) != 0, (bitmask & 0x02) != 0, (bitmask & 0x04) != 0);
}

// Core CW Filter Width display update logic
static void update_cw_filter_width_display(uint16_t new_width) {
    // Always cache latest CW width; update label immediately if present
    s_current_cw_filter_width_hz = new_width;
    ESP_LOGD("UI_Screen1", "FW Updated: CW Width %u Hz (cached)", s_current_cw_filter_width_hz);

    if (lv_obj_is_valid(ui_CwFilterWidth)) {
        static char buf[6]; // Max "9999" + null
        snprintf(buf, sizeof(buf), "%u", s_current_cw_filter_width_hz);
        lv_label_set_text(ui_CwFilterWidth, buf);
    }
}

// LVGL 9 observer callback for CW Filter Width updates
static void update_cw_filter_width_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_cw_filter_width_display((uint16_t)lv_subject_get_int(subject));
}

// Callback for SH (High-Cut or Shift) filter updates
// SH meaning depends on EX028/EX029 filter mode:
//   Mode 0 (Hi/Lo Cut): SH = High-cut frequency
//   Mode 1 (Width/Shift): SH = Shift frequency
// Core SH (High-Cut/Shift) filter display update logic
static void update_sh_filter_display(uint8_t idx) {
    const uint16_t *current_options_array = NULL;
    size_t current_options_size = 0;
    const char *table_name = "unknown";

    // Determine which table to use based on mode and EX028/EX029 settings
    switch (s_current_radio_mode) {
        case 1: case 2: // LSB/USB
            if (g_data_mode_active) {
                if (radio_get_ssb_data_filter_mode() == 1) {
                    current_options_array = shift_options;
                    current_options_size = sizeof(shift_options) / sizeof(shift_options[0]);
                    table_name = "shift (SSB-DATA)";
                } else {
                    current_options_array = high_cut_options;
                    current_options_size = sizeof(high_cut_options) / sizeof(high_cut_options[0]);
                    table_name = "high-cut (SSB-DATA)";
                }
            } else {
                if (radio_get_ssb_filter_mode() == 1) {
                    current_options_array = shift_options;
                    current_options_size = sizeof(shift_options) / sizeof(shift_options[0]);
                    table_name = "shift (SSB)";
                } else {
                    current_options_array = high_cut_options;
                    current_options_size = sizeof(high_cut_options) / sizeof(high_cut_options[0]);
                    table_name = "high-cut (SSB)";
                }
            }
            break;
        case 4: // FM
            current_options_array = high_cut_options;
            current_options_size = sizeof(high_cut_options) / sizeof(high_cut_options[0]);
            table_name = "high-cut (FM)";
            break;
        case 5: // AM
            current_options_array = am_high_cut_options;
            current_options_size = sizeof(am_high_cut_options) / sizeof(am_high_cut_options[0]);
            table_name = "high-cut (AM)";
            break;
        default:
            ESP_LOGD("UI_Screen1", "SH received in mode %d (ignored)", s_current_radio_mode);
            return;
    }

    if (current_options_size == 0) return;
    if (idx >= current_options_size) {
        ESP_LOGW("UI_Screen1", "SH idx %u out of bounds (max %u, table=%s) — clamping",
                 idx, (unsigned)(current_options_size - 1), table_name);
        idx = (uint8_t)(current_options_size - 1);
    }
    s_current_high_cut_hz = current_options_array[idx];
    ESP_LOGI("UI_Screen1", "SH: idx=%u -> %u Hz (%s)", idx, s_current_high_cut_hz, table_name);
    refresh_filter_display_for_current_mode();
}

// LVGL 9 observer callback for SH filter updates
static void update_sh_filter_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_sh_filter_display((uint8_t)lv_subject_get_int(subject));
}

// Callback for SL (Low-Cut or Width) filter updates
// SL meaning depends on EX028/EX029 filter mode:
//   Mode 0 (Hi/Lo Cut): SL = Low-cut frequency
//   Mode 1 (Width/Shift): SL = Width
// Core SL (Low-Cut/Width) filter display update logic
static void update_sl_filter_display(uint8_t idx) {
    const uint16_t *current_options_array = NULL;
    size_t current_options_size = 0;
    const char *table_name = "unknown";

    // Determine which table to use based on mode and EX028/EX029 settings
    // s_current_radio_mode: 1=LSB, 2=USB, 3=CW, 4=FM, 5=AM, 6=FSK, 7=CW-R, 9=FSK-R
    switch (s_current_radio_mode) {
        case 1: // LSB
        case 2: // USB
            // Check EX028 (SSB) or EX029 (SSB-DATA) based on DATA mode
            if (g_data_mode_active) {
                // SSB-DATA mode: use EX029 setting
                if (radio_get_ssb_data_filter_mode() == 1) {
                    current_options_array = width_options;
                    current_options_size = sizeof(width_options) / sizeof(width_options[0]);
                    table_name = "width (SSB-DATA)";
                } else {
                    current_options_array = low_cut_options;
                    current_options_size = sizeof(low_cut_options) / sizeof(low_cut_options[0]);
                    table_name = "low-cut (SSB-DATA)";
                }
            } else {
                // SSB mode: use EX028 setting
                if (radio_get_ssb_filter_mode() == 1) {
                    current_options_array = width_options;
                    current_options_size = sizeof(width_options) / sizeof(width_options[0]);
                    table_name = "width (SSB)";
                } else {
                    current_options_array = low_cut_options;
                    current_options_size = sizeof(low_cut_options) / sizeof(low_cut_options[0]);
                    table_name = "low-cut (SSB)";
                }
            }
            break;
        case 4: // FM
            // FM always uses low-cut (no Width/Shift option)
            current_options_array = low_cut_options;
            current_options_size = sizeof(low_cut_options) / sizeof(low_cut_options[0]);
            table_name = "low-cut (FM)";
            break;
        case 5: // AM
            current_options_array = am_low_cut_options;
            current_options_size = sizeof(am_low_cut_options) / sizeof(am_low_cut_options[0]);
            table_name = "low-cut (AM)";
            break;
        default:
            // CW (3,7) and FSK (6,9) don't use SL for low-cut
            ESP_LOGD("UI_Screen1", "SL received in mode %d (ignored)", s_current_radio_mode);
            return;
    }

    if (current_options_size == 0) return;
    if (idx >= current_options_size) {
        ESP_LOGW("UI_Screen1", "SL idx %u out of bounds (max %u, table=%s) — clamping",
                 idx, (unsigned)(current_options_size - 1), table_name);
        idx = (uint8_t)(current_options_size - 1);
    }
    s_current_low_cut_hz = current_options_array[idx];
    ESP_LOGI("UI_Screen1", "SL: idx=%u -> %u Hz (%s)", idx, s_current_low_cut_hz, table_name);
    refresh_filter_display_for_current_mode();
}

// LVGL 9 observer callback for SL filter updates
static void update_sl_filter_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_sl_filter_display((uint8_t)lv_subject_get_int(subject));
}

// Core XI data display update logic
static void update_xi_data_display(const kenwood_xi_data_t *xi_data) {
    if (!xi_data) {
        return;
    }
    // Log or use xi_data if needed for debugging or UI updates
    ESP_LOGD("UI_Screen1", "XI Data Received: Freq=%" PRIu32 ", Mode=%d, DataMode=%s",
             xi_data->transmit_frequency, xi_data->transmission_mode, xi_data->data_mode_on ? "ON" : "OFF");
}

// LVGL 9 observer callback for XI data updates
static void update_xi_data_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    const kenwood_xi_data_t *xi_data = (const kenwood_xi_data_t *)lv_subject_get_pointer(subject);
    update_xi_data_display(xi_data);
}

// New LVGL Timer callback to check for CAT data activity using cat_parser flag
static void ui_cat_activity_check_timer_cb(lv_timer_t *timer) {
    LV_UNUSED(timer);

    if (!lv_obj_is_valid(ui_CatConnectedLabel)) {
        return;
    }

    if (cat_check_and_reset_activity_flag()) {
        // Activity was detected by cat_parser since the last check
        const char *current_text = lv_label_get_text(ui_CatConnectedLabel);
        if (current_text == NULL || strcmp(current_text, "H") != 0) {
            lv_label_set_text(ui_CatConnectedLabel, "H"); // Set to "Connected"
        }
        ui_last_cat_activity_time = lv_tick_get(); // Update timestamp of last known activity
        ESP_LOGD("UI_Screen1", "CAT activity detected by UI timer. Label set to Connected.");
    } else {
        // No new activity in this check cycle. Check if timeout has occurred.
        if (lv_tick_elaps(ui_last_cat_activity_time) > CAT_INACTIVITY_TIMEOUT_MS) {
            const char *current_text = lv_label_get_text(ui_CatConnectedLabel);
            if (current_text == NULL || strcmp(current_text, "I") != 0) {
                lv_label_set_text(ui_CatConnectedLabel, "I"); // Set to "Inactive/Disconnected"
                ESP_LOGI("UI_Screen1", "CAT Inactivity timeout (UI timer). Label set to Inactive.");
                // Clear all meters when CAT connection is lost to prevent stuck segments
                force_clear_all_meters();
                reset_s_meter_state_tracking();
            }
        }
    }

    // TX stuck protection: If display shows TX but IF hasn't confirmed it recently, force RX
    // This handles cases where TX command arrived but radio didn't actually transmit,
    // or IF responses were lost/delayed. 2 second timeout allows for queue backlog during
    // heavy TX traffic (meters, SWR, ALC all generate messages).
    if (s_tx_active && s_tx_last_confirmed_time > 0) {
        uint32_t elapsed = lv_tick_elaps(s_tx_last_confirmed_time);
        if (elapsed > TX_STUCK_TIMEOUT_MS) {
            ESP_LOGW("UI_Screen1", "TX stuck timeout: no IF confirmation for %lu ms - forcing RX display",
                     (unsigned long)elapsed);
            s_tx_active = false;
            s_tx_last_confirmed_time = 0; // Reset to prevent repeated warnings
            update_rxtx_label_status(false);
        }
    }
}

// Core Actual SWR Float update logic
static void update_actual_swr_float_display(float actual_swr) {
    ESP_LOGD("UI_Screen1", "Actual SWR (float) received: %.2f", actual_swr);
    // TODO: Use this float value in the UI if needed in the future, e.g., display as text.
}

// LVGL 9 observer callback for Actual SWR Float updates
#if LV_USE_FLOAT
static void update_actual_swr_float_observer_cb(lv_observer_t *observer, lv_subject_t *subject) {
    LV_UNUSED(observer);
    update_actual_swr_float_display(lv_subject_get_float(subject));
}
#endif

// event functions
void ui_event_Switch1(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t *target = (lv_obj_t*)lv_event_get_target(e);

    if (event_code == LV_EVENT_VALUE_CHANGED && lv_obj_has_state(target, LV_STATE_CHECKED)) {
        if (lv_obj_is_valid(ui_VfoAButtonBackground)) _ui_flag_modify(ui_VfoAButtonBackground, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_ADD);
        if (lv_obj_is_valid(ui_VfoBButtonBackground)) _ui_flag_modify(ui_VfoBButtonBackground, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
    }
    if (event_code == LV_EVENT_VALUE_CHANGED && !lv_obj_has_state(target, LV_STATE_CHECKED)) {
        if (lv_obj_is_valid(ui_VfoAButtonBackground)) _ui_flag_modify(ui_VfoAButtonBackground, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
        if (lv_obj_is_valid(ui_VfoBButtonBackground)) _ui_flag_modify(ui_VfoBButtonBackground, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_ADD);
    }
}

// Removed: Mode is now display-only label, not interactive
// void ui_event_ModeDropDown(lv_event_t *e) {
//     lv_event_code_t event_code = lv_event_get_code(e);
//     if (event_code == LV_EVENT_VALUE_CHANGED) {
//         changeMode(e);
//     }
// }

void ui_event_changeAntenna(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_CLICKED) {
        changeAntenna(e);
        // Label visibility is now controlled by update_antenna_status_cb based on actual CAT response
    }
}

void ui_event_UtcTime(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_SCREEN_LOADED) {
        setUtcTime(e);
    }
}

void ui_event_IfFilter(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_CLICKED) {
        // Toggle between Filter A (1) and Filter B (2)
        int new_filter = (current_filter == 1) ? 2 : 1;
        
        // Send FL command to radio
        char fl_command[8];
        snprintf(fl_command, sizeof(fl_command), "FL%d;", new_filter);
        uart_write_message(fl_command);
        
        // Update UI immediately (will also be updated when radio responds with FL command)
        ui_screen1_update_filter(new_filter);
    }
}

void ui_event_RxTxLabel(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    // lv_obj_t *target = (lv_obj_t*)lv_event_get_target(e); // Unused variable

    if (event_code == LV_EVENT_CLICKED) {
        // UI update logic moved to update_rxtx_label_status via TX status observer.
        // If this button is intended to initiate TX/RX, it should send a CAT command.
    }
}

// Force clear all S-meter segments to ensure clean visual state
// Uses delta tracking to only clear segments that are actually on
static void force_clear_s_meter_segments(void) {
    if (!lv_obj_is_valid(ui_SMeterSegmentsContainer)) return;

    int cleared = 0;
    for (int i = 0; i < 30; i++) {
        // Only clear if tracking says it's on - avoids redundant LVGL calls
        if (s_meter_prev_state[i] != 0 &&
            ui_SMeterSegments[i] != NULL && lv_obj_is_valid(ui_SMeterSegments[i])) {
            lv_bar_set_value(ui_SMeterSegments[i], 0, LV_ANIM_OFF);
            s_meter_prev_state[i] = 0;
            cleared++;
        }
    }
    if (cleared > 0) {
        ESP_LOGD("UI_Screen1", "Cleared %d S-meter segments", cleared);
    }
}

// Force clear all SWR meter segments using delta tracking
static void force_clear_swr_meter_segments(void) {
    if (!lv_obj_is_valid(ui_SwrMeterSegmentsContainer)) return;

    int cleared = 0;
    for (int i = 0; i < 30; i++) {
        if (swr_meter_prev_state[i] != 0 &&
            ui_SwrMeterSegments[i] != NULL && lv_obj_is_valid(ui_SwrMeterSegments[i])) {
            lv_bar_set_value(ui_SwrMeterSegments[i], 0, LV_ANIM_OFF);
            swr_meter_prev_state[i] = 0;
            cleared++;
        }
    }
    swr_meter_prev_current = 0;
    swr_display_value = 0;
    if (cleared > 0) {
        ESP_LOGD("UI_Screen1", "Cleared %d SWR meter segments", cleared);
    }
}

// Force clear all ALC meter segments using delta tracking
static void force_clear_alc_meter_segments(void) {
    if (!lv_obj_is_valid(ui_AlcMeterSegmentsContainer)) return;

    int cleared = 0;
    for (int i = 0; i < 30; i++) {
        if (alc_meter_prev_state[i] != 0 &&
            ui_AlcMeterSegments[i] != NULL && lv_obj_is_valid(ui_AlcMeterSegments[i])) {
            lv_bar_set_value(ui_AlcMeterSegments[i], 0, LV_ANIM_OFF);
            alc_meter_prev_state[i] = 0;
            cleared++;
        }
    }
    alc_meter_prev_current = 0;
    alc_display_value = 0;
    if (cleared > 0) {
        ESP_LOGD("UI_Screen1", "Cleared %d ALC meter segments", cleared);
    }
}

// Force clear all meters (S-meter, SWR, ALC)
static void force_clear_all_meters(void) {
    force_clear_s_meter_segments();
    force_clear_swr_meter_segments();
    force_clear_alc_meter_segments();
}

// Debug function to verify S-meter state consistency
static void debug_s_meter_state(const char *context) {
    if (!lv_obj_is_valid(ui_SMeterSegmentsContainer)) return;
    
    int segments_on = 0;
    int tracking_on = 0;
    
    for (int i = 0; i < 30; i++) {
        if (ui_SMeterSegments[i] != NULL && lv_obj_is_valid(ui_SMeterSegments[i])) {
            int visual_state = lv_bar_get_value(ui_SMeterSegments[i]);
            if (visual_state == 1) segments_on++;
        }
        if (s_meter_prev_state[i] == 1) tracking_on++;
    }
    
    if (segments_on != tracking_on) {
        ESP_LOGW("UI_Screen1", "%s: State mismatch - Visual:%d vs Tracking:%d", 
                context, segments_on, tracking_on);
    } else {
        ESP_LOGD("UI_Screen1", "%s: State consistent - %d segments on", context, segments_on);
    }
}

// Reset S-meter state tracking for clean slate
static void reset_s_meter_state_tracking(void) {
    for (int i = 0; i < 30; i++) {
        s_meter_prev_state[i] = 0;
    }
    s_meter_prev_current = -1;
    s_meter_prev_peak = -1;
    s_meter_prev_peak_enabled = false;
}

// Function to update RX/TX label and related UI elements
static void update_rxtx_label_status(bool is_transmitting) {
    s_meter_peak_value = 0; // Reset peak value whenever TX/RX state changes
    s_meter_current_value = 0; // Reset current value as well
    s_meter_peak_last_update_time = 0; // Reset timestamp as well

    // Reset power meter calibration when exiting TX mode
    if (!is_transmitting) {
        max_sm_tx_value = 30;  // Reset to default for next TX session
    }

    // Clear segments BEFORE resetting tracking - force_clear uses tracking to know which segments need clearing
    force_clear_s_meter_segments();
    reset_s_meter_state_tracking(); // Reset delta tracking for clean state

    // Check if we need to switch meter layout mode based on TX/RX and PROC states
    meter_layout_mode_t target_mode = METER_LAYOUT_SINGLE_ALC;
    if (is_transmitting && s_proc_enabled) {
        target_mode = METER_LAYOUT_DUAL_ALC_COMP;
    }

    if (s_current_meter_layout != target_mode) {
        ESP_LOGI("RXTX_UPDATE", "TX=%d PROC=%d -> switching to %s mode",
                 is_transmitting, s_proc_enabled,
                 (target_mode == METER_LAYOUT_DUAL_ALC_COMP) ? "DUAL" : "SINGLE");
        switch_meter_layout_mode(target_mode);
    }

    if (lv_obj_is_valid(ui_RxTxLabel)) {
        if (is_transmitting) {
            lv_label_set_text(ui_RxTxLabel, "TX");
            lv_obj_add_state(ui_RxTxLabel, LV_STATE_CHECKED);

            // Hide S-unit label container, show Power scale label
            if (lv_obj_is_valid(ui_SMeterLabelsContainer))
                _ui_flag_modify(ui_SMeterLabelsContainer, LV_OBJ_FLAG_HIDDEN,
                                _UI_MODIFY_FLAG_ADD);


            if (lv_obj_is_valid(ui_PwrLabelsContainer)) _ui_flag_modify(ui_PwrLabelsContainer, LV_OBJ_FLAG_HIDDEN,
                                                                        _UI_MODIFY_FLAG_REMOVE); // MODIFIED

            if (lv_obj_is_valid(ui_SMeterLabel)) _ui_flag_modify(ui_SMeterLabel, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_ADD);
            if (lv_obj_is_valid(ui_PwrLabel)) _ui_flag_modify(ui_PwrLabel, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);

            // Force invalidate the area to ensure proper redraw - REMOVED as _ui_flag_modify handles invalidation
            // if (lv_obj_is_valid(ui_SMeterLabelsContainer)) lv_obj_invalidate(ui_SMeterLabelsContainer);
            // if (lv_obj_is_valid(ui_PwrLabelsContainer)) lv_obj_invalidate(ui_PwrLabelsContainer);
        } else {
            // Receiving
            lv_label_set_text(ui_RxTxLabel, "RX");
            lv_obj_remove_state(ui_RxTxLabel, LV_STATE_CHECKED);

            // Show S-unit label container, hide Power scale label
            if (lv_obj_is_valid(ui_SMeterLabelsContainer))
                _ui_flag_modify(ui_SMeterLabelsContainer, LV_OBJ_FLAG_HIDDEN,
                                _UI_MODIFY_FLAG_REMOVE);
            if (lv_obj_is_valid(ui_PwrLabelsContainer)) _ui_flag_modify(ui_PwrLabelsContainer, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_ADD);
            // MODIFIED

            if (lv_obj_is_valid(ui_SMeterLabel)) _ui_flag_modify(ui_SMeterLabel, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
            if (lv_obj_is_valid(ui_PwrLabel)) _ui_flag_modify(ui_PwrLabel, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_ADD);

            // Force invalidate the area to ensure proper redraw - REMOVED as _ui_flag_modify handles invalidation
            // if (lv_obj_is_valid(ui_SMeterLabelsContainer)) lv_obj_invalidate(ui_SMeterLabelsContainer);
            // if (lv_obj_is_valid(ui_PwrLabelsContainer)) lv_obj_invalidate(ui_PwrLabelsContainer);
        }
    }
}

void ui_event_PreAmpButton(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_VALUE_CHANGED) {
        // Add safety check to prevent commands during initialization
        if (!lv_obj_is_valid(ui_PreAmpButton)) return;
        
        // Check the actual current state after the change
        bool is_checked = lv_obj_has_state(ui_PreAmpButton, LV_STATE_CHECKED);
        ESP_LOGI("UI_PREAMP", "PreAmp button state changed to: %s", is_checked ? "ON" : "OFF");
        
        if (is_checked) {
            uart_write_message("PA1;");
        } else {
            uart_write_message("PA0;");
        }
    }
}

void ui_event_AttButton(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_VALUE_CHANGED) {
        if (!lv_obj_is_valid(ui_AttButton)) return;
        
        bool is_checked = lv_obj_has_state(ui_AttButton, LV_STATE_CHECKED);
        ESP_LOGI("UI_ATT", "ATT button state changed to: %s", is_checked ? "ON" : "OFF");
        
        if (is_checked) {
            uart_write_message("RA01;");
        } else {
            uart_write_message("RA00;");
        }
    }
}

void ui_event_AtTuneButton(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_CLICKED) {
        uart_write_message("AC111;");
    }
}

void ui_event_ProcButton(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_VALUE_CHANGED) {
        if (!lv_obj_is_valid(ui_ProcButton)) return;
        
        bool is_checked = lv_obj_has_state(ui_ProcButton, LV_STATE_CHECKED);
        ESP_LOGI("UI_PROC", "PROC button state changed to: %s", is_checked ? "ON" : "OFF");
        
        if (is_checked) {
            uart_write_message("PR1;");
        } else {
            uart_write_message("PR0;");
        }
    }
}

void ui_event_IncreaseSwrButton(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_CLICKED) {
        // Functionality removed as ui_SwrMeterBar is obsolete.
    }
}

void ui_event_IncreaseSwrLabel(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_PRESSED) {
        // Functionality removed as ui_SwrMeterBar is obsolete.
    }
}

void ui_event_DecreaseSwrButton(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_CLICKED) {
        // Functionality removed as ui_SwrMeterBar is obsolete.
    }
}

void ui_event_IncreaseSMeterButton(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_CLICKED) {
        // Functionality removed as ui_SMeterBar is obsolete.
    }
}

void ui_event_DecreaseSMeterButton(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_CLICKED) {
        // Functionality removed as ui_SMeterBar is obsolete.
    }
}

void ui_event_SplitButton(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_CLICKED) {
        // Toggle split mode based on current RX VFO
        // If RX is on VFO A, set TX to VFO B (split mode)
        // If RX is on VFO B, set TX to VFO A (split mode)
        // This implements the split mode toggle logic described in user requirements
        
        // Get current RX VFO function from CAT parser
        int current_rx_vfo = cat_get_rx_vfo_function();
        
        if (current_rx_vfo == 0) {
            // RX=VFO A, set TX=VFO B to enable split mode
            uart_write_message("FR0;"); // Ensure RX is VFO A
            uart_write_message("FT1;"); // Set TX to VFO B
        } else if (current_rx_vfo == 1) {
            // RX=VFO B, set TX=VFO A to enable split mode  
            uart_write_message("FR1;"); // Ensure RX is VFO B
            uart_write_message("FT0;"); // Set TX to VFO A
        }
        // Note: Memory mode (current_rx_vfo == 2) not handled for split
    }
}

void ui_event_NrButton(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_CLICKED) {
        if (!lv_obj_is_valid(ui_NrButton)) return;
        
        // Cycle through NR modes: 0=OFF, 1=NR1, 2=NR2
        nr_mode = (nr_mode + 1) % 3;
        
        const char* mode_names[] = {"OFF", "NR1", "NR2"};
        ESP_LOGI("UI_NR", "NR button clicked, cycling to: %s", mode_names[nr_mode]);
        
        // Update button appearance and label
        if (nr_mode == 0) {
            lv_obj_remove_state(ui_NrButton, LV_STATE_CHECKED);
            uart_write_message("NR0;");
        } else {
            lv_obj_add_state(ui_NrButton, LV_STATE_CHECKED);
            if (nr_mode == 1) {
                uart_write_message("NR1;");
            } else { // nr_mode == 2
                uart_write_message("NR2;");
            }
        }
        
        // Update button label to show current mode
        update_nr_button_label();
    }
}

void ui_event_NbButton(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_CLICKED) {
        if (!lv_obj_is_valid(ui_NbButton)) return;
        
        // Cycle through NB modes: 0=OFF, 1=NB1, 2=NB2, 3=NB3
        nb_mode = (nb_mode + 1) % 4;
        
        const char* mode_names[] = {"OFF", "NB1", "NB2", "NB3"};
        ESP_LOGI("UI_NB", "NB button clicked, cycling to: %s", mode_names[nb_mode]);
        
        // Update button appearance
        if (nb_mode == 0) {
            lv_obj_remove_state(ui_NbButton, LV_STATE_CHECKED);
            uart_write_message("NB0;");
        } else {
            lv_obj_add_state(ui_NbButton, LV_STATE_CHECKED);
            if (nb_mode == 1) {
                uart_write_message("NB1;");
            } else if (nb_mode == 2) {
                uart_write_message("NB2;");
            } else { // nb_mode == 3
                uart_write_message("NB3;");
            }
        }
        
        // Update button label to show current mode
        update_nb_button_label();
    }
}

void ui_event_DebugMode(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_CLICKED) {
        // Obsolete SWR bar manipulation removed.
        _ui_screen_change(&ui_Screen2, LV_SCR_LOAD_ANIM_NONE, 0, 0, &ui_Screen2_screen_init);
        // Screen2 is pre-created; direct screen change is used
    }
}

void ui_event_SettingsButton(lv_event_t *e) {
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code == LV_EVENT_CLICKED) {
        _ui_screen_change(&ui_Screen2, LV_SCR_LOAD_ANIM_NONE, 0, 0, &ui_Screen2_screen_init);
        // Screen2 is pre-created; direct screen change is used
    }
}

// build functions
// Grid column descriptors for meter label containers - scaled to bar_width
static lv_coord_t grid_cols_30_scaled[31];  // Runtime-initialized in ui_Screen1_screen_init

/**
 * @brief Switch ALC meter layout between single (30 seg) and dual (15 seg ALC + 15 seg COMP) modes
 *
 * Layout dimensions:
 * - Single mode: 30 segments × ui_sx(7) + 29 gaps × ui_sx(2) = scaled 268px equivalent
 * - Dual mode: 2 × (15 segments × ui_sx(4) + 14 gaps × ui_sx(2)) + labels = same total
 *   All pixel values are scaled via ui_sx()/ui_sy() for multi-resolution support.
 *
 * @param new_mode Target layout mode (METER_LAYOUT_SINGLE_ALC or METER_LAYOUT_DUAL_ALC_COMP)
 */
static void switch_meter_layout_mode(meter_layout_mode_t new_mode) {
    if (s_current_meter_layout == new_mode) {
        return; // Already in requested mode
    }

    ESP_LOGI("METER_LAYOUT", "Switching from %s to %s",
             (s_current_meter_layout == METER_LAYOUT_SINGLE_ALC) ? "SINGLE" : "DUAL",
             (new_mode == METER_LAYOUT_SINGLE_ALC) ? "SINGLE" : "DUAL");

    const lv_coord_t bar_gap_px = ui_sx(2);
    const lv_coord_t bar_height = ui_sy(22);
    const lv_coord_t alc_meter_y_pos = ui_sy(62); // Fixed Y position for ALC meter row
    const lv_coord_t single_seg_w = ui_sx(7);
    const lv_coord_t fixed_meter_area_width = 30 * single_seg_w + 29 * bar_gap_px;
    const lv_coord_t common_meter_area_x_pos = ui_sx(190) - (fixed_meter_area_width / 2) + ui_sx(5);

    if (new_mode == METER_LAYOUT_DUAL_ALC_COMP) {
        // === DUAL MODE: 15 seg ALC + 15 seg COMP ===
        const lv_coord_t dual_segment_width = ui_sx(4);
        const lv_coord_t dual_segment_count = 15;
        const lv_coord_t single_meter_width = (dual_segment_count * dual_segment_width) +
                                               ((dual_segment_count - 1) * bar_gap_px); // 88px

        // Destroy existing 30-segment ALC meter
        if (ui_AlcMeterSegmentsContainer && lv_obj_is_valid(ui_AlcMeterSegmentsContainer)) {
            for (int i = 0; i < 30; i++) {
                if (ui_AlcMeterSegments[i] && lv_obj_is_valid(ui_AlcMeterSegments[i])) {
                    lv_obj_delete(ui_AlcMeterSegments[i]);
                    ui_AlcMeterSegments[i] = NULL;
                }
            }
        }

        // Reset ALC display value and state tracking for fresh start
        alc_display_value = 0;
        alc_meter_prev_current = -1; // Force redraw on next update
        for (int i = 0; i < 30; i++) {
            alc_meter_prev_state[i] = 0;
        }

        // Recreate ALC container with 15 segments
        if (ui_AlcMeterSegmentsContainer && lv_obj_is_valid(ui_AlcMeterSegmentsContainer)) {
            lv_obj_set_width(ui_AlcMeterSegmentsContainer, single_meter_width);

            // Initialize ALC color zones for 15 segments (0-10 blue, 11-14 red)
            for (int k = 0; k < 15; k++) {
                alc_meter_on_colors[k] = (k < 11) ? lv_color_hex(COLOR_BLUE_METER_S_UNITS)
                                                   : lv_color_hex(COLOR_RED_METER_HIGH);
            }

            create_meter_segments(ui_AlcMeterSegmentsContainer, ui_AlcMeterSegments, dual_segment_count,
                                  dual_segment_width, bar_height, alc_meter_on_colors);

            // Reposition ALC meter to left side (40px label + meter starts at common_meter_area_x_pos)
            lv_obj_set_pos(ui_AlcMeterSegmentsContainer, common_meter_area_x_pos, alc_meter_y_pos);
        }

        // Move ALC label closer to meter
        if (ui_AlcLabel && lv_obj_is_valid(ui_AlcLabel)) {
            lv_obj_set_x(ui_AlcLabel, ui_sx(-374)); // Keep original X
        }

        // Delete existing COMP segments before creating new ones (handles mode switch cycling)
        for (int i = 0; i < 15; i++) {
            if (ui_CompMeterSegments[i] && lv_obj_is_valid(ui_CompMeterSegments[i])) {
                lv_obj_delete(ui_CompMeterSegments[i]);
                ui_CompMeterSegments[i] = NULL;
            }
        }

        // Create COMP meter container if it doesn't exist
        if (!ui_CompMeterSegmentsContainer || !lv_obj_is_valid(ui_CompMeterSegmentsContainer)) {
            ui_CompMeterSegmentsContainer = lv_obj_create(ui_Screen1);
            lv_obj_remove_style_all(ui_CompMeterSegmentsContainer);
            lv_obj_add_flag(ui_CompMeterSegmentsContainer, LV_OBJ_FLAG_OVERFLOW_VISIBLE);
            lv_obj_set_height(ui_CompMeterSegmentsContainer, LV_SIZE_CONTENT);
            lv_obj_set_align(ui_CompMeterSegmentsContainer, LV_ALIGN_TOP_LEFT);
            lv_obj_set_layout(ui_CompMeterSegmentsContainer, LV_LAYOUT_FLEX);
            lv_obj_set_flex_flow(ui_CompMeterSegmentsContainer, LV_FLEX_FLOW_ROW);
            lv_obj_set_flex_align(ui_CompMeterSegmentsContainer, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER,
                                  LV_FLEX_ALIGN_CENTER);
            lv_obj_set_style_pad_column(ui_CompMeterSegmentsContainer, bar_gap_px, 0);
            lv_obj_set_style_pad_left(ui_CompMeterSegmentsContainer, 0, 0);
            lv_obj_set_style_pad_right(ui_CompMeterSegmentsContainer, 0, 0);
        }

        // Initialize COMP color zones (0-10 blue, 11-14 red)
        for (int k = 0; k < 15; k++) {
            comp_meter_on_colors[k] = (k < 11) ? lv_color_hex(COLOR_BLUE_METER_S_UNITS)
                                                : lv_color_hex(COLOR_RED_METER_HIGH);
        }

        // Reset COMP display value for fresh start
        comp_display_value = 0;

        // Create COMP meter segments
        lv_obj_set_width(ui_CompMeterSegmentsContainer, single_meter_width);
        create_meter_segments(ui_CompMeterSegmentsContainer, ui_CompMeterSegments, dual_segment_count,
                              dual_segment_width, bar_height, comp_meter_on_colors);

        // Position COMP meter to right of ALC: ALC_end + gap + COMP_label_space
        // ALC starts at common_meter_area_x_pos, is 88px wide
        // Leave 12px gap, then 40px for COMP label
        const lv_coord_t comp_meter_x = common_meter_area_x_pos + single_meter_width + ui_sx(12) + ui_sx(40);
        lv_obj_set_pos(ui_CompMeterSegmentsContainer, comp_meter_x, alc_meter_y_pos);
        lv_obj_remove_flag(ui_CompMeterSegmentsContainer, LV_OBJ_FLAG_HIDDEN);

        // Create COMP label if it doesn't exist
        if (!ui_CompLabel || !lv_obj_is_valid(ui_CompLabel)) {
            ui_CompLabel = lv_label_create(ui_Screen1);
            lv_obj_set_width(ui_CompLabel, LV_SIZE_CONTENT);
            lv_obj_set_height(ui_CompLabel, LV_SIZE_CONTENT);
            lv_label_set_text(ui_CompLabel, "COMP");
            lv_obj_set_style_text_align(ui_CompLabel, LV_TEXT_ALIGN_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
            lv_obj_set_style_text_font(ui_CompLabel, ui_meter_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
        }

        // Position COMP label (center Y with meter, left of COMP meter)
        // comp_meter_x - label_space, converted to center-based coordinates
        lv_obj_set_align(ui_CompLabel, LV_ALIGN_CENTER);
        const lv_coord_t comp_label_y_offset = alc_meter_y_pos + ui_sy(11) - (V_RES / 2);
        lv_obj_set_x(ui_CompLabel, comp_meter_x - (H_RES / 2) - ui_sx(40));
        lv_obj_set_y(ui_CompLabel, comp_label_y_offset);
        lv_obj_remove_flag(ui_CompLabel, LV_OBJ_FLAG_HIDDEN);

    } else {
        // === SINGLE MODE: 30 seg ALC ===
        const lv_coord_t single_segment_width = single_seg_w;
        const lv_coord_t single_segment_count = 30;

        // Hide COMP meter and label
        if (ui_CompMeterSegmentsContainer && lv_obj_is_valid(ui_CompMeterSegmentsContainer)) {
            lv_obj_add_flag(ui_CompMeterSegmentsContainer, LV_OBJ_FLAG_HIDDEN);
        }
        if (ui_CompLabel && lv_obj_is_valid(ui_CompLabel)) {
            lv_obj_add_flag(ui_CompLabel, LV_OBJ_FLAG_HIDDEN);
        }

        // Destroy existing 15-segment ALC meter
        if (ui_AlcMeterSegmentsContainer && lv_obj_is_valid(ui_AlcMeterSegmentsContainer)) {
            for (int i = 0; i < 30; i++) { // Clear full array
                if (ui_AlcMeterSegments[i] && lv_obj_is_valid(ui_AlcMeterSegments[i])) {
                    lv_obj_delete(ui_AlcMeterSegments[i]);
                    ui_AlcMeterSegments[i] = NULL;
                }
            }
        }

        // Reset ALC display value and state tracking for fresh start
        alc_display_value = 0;
        alc_meter_prev_current = -1; // Force redraw on next update
        for (int i = 0; i < 30; i++) {
            alc_meter_prev_state[i] = 0;
        }

        // Recreate ALC container with 30 segments
        if (ui_AlcMeterSegmentsContainer && lv_obj_is_valid(ui_AlcMeterSegmentsContainer)) {
            lv_obj_set_width(ui_AlcMeterSegmentsContainer, fixed_meter_area_width);

            // Initialize ALC color zones for 30 segments (0-20 blue, 21-29 red)
            for (int k = 0; k < 30; k++) {
                alc_meter_on_colors[k] = (k < 21) ? lv_color_hex(COLOR_BLUE_METER_S_UNITS)
                                                   : lv_color_hex(COLOR_RED_METER_HIGH);
            }

            create_meter_segments(ui_AlcMeterSegmentsContainer, ui_AlcMeterSegments, single_segment_count,
                                  single_segment_width, bar_height, alc_meter_on_colors);

            // Restore original ALC position
            lv_obj_set_pos(ui_AlcMeterSegmentsContainer, common_meter_area_x_pos, alc_meter_y_pos);
        }

        // Restore ALC label position
        if (ui_AlcLabel && lv_obj_is_valid(ui_AlcLabel)) {
            lv_obj_set_x(ui_AlcLabel, ui_sx(-374)); // Original position
        }
    }

    s_current_meter_layout = new_mode;
    s_meter_mode_switch_time = lv_tick_get(); // Start debounce timer
    ESP_LOGI("METER_LAYOUT", "Layout switch complete, debounce for %dms", METER_MODE_SWITCH_DEBOUNCE_MS);
}

void ui_Screen1_screen_init(void) {
    // Initialize peak decay interval and S-meter averaging from settings
    user_settings_t settings;
    if (settings_load(&settings) == ESP_OK) {
        g_peak_decay_interval_ms = settings.peak_hold_duration_ms;
        // Initialize the static variable in the message callback scope
        s_meter_averaging_enabled = settings.smeter_averaging_enabled;
        // Initialize peak hold enabled state and timer based on stored setting
        g_peak_hold_enabled = settings.peak_hold_enabled;
        if (g_peak_hold_enabled && peak_decay_timer == NULL) {
            peak_decay_timer = lv_timer_create(peak_decay_timer_cb, 100, NULL);
            if (peak_decay_timer) {
                lv_timer_set_repeat_count(peak_decay_timer, -1);
            } else {
                ESP_LOGE("UI_Screen1", "Failed to create peak_decay_timer during init");
            }
        }
        ESP_LOGI("UI_Screen1", "Loaded peak hold: %s, duration: %lu ms, S-meter averaging: %s",
                 g_peak_hold_enabled ? "ON" : "OFF",
                 g_peak_decay_interval_ms,
                 s_meter_averaging_enabled ? "ON" : "OFF");
    } else {
        g_peak_decay_interval_ms = DEFAULT_PEAK_HOLD_DURATION;
        ESP_LOGW("UI_Screen1", "Failed to load settings, using default peak hold duration: %d ms", DEFAULT_PEAK_HOLD_DURATION);
    }

    ui_Screen1 = lv_obj_create(NULL);
    lv_obj_add_event_cb(ui_Screen1, screen1_del_cb, LV_EVENT_DELETE, NULL); // Register delete event handler
    lv_obj_remove_flag(ui_Screen1, (lv_obj_flag_t)(LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                                  LV_OBJ_FLAG_SCROLL_MOMENTUM)); /// Flags
    lv_obj_set_style_text_font(ui_Screen1, ui_font18(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_Screen1, 0, LV_PART_MAIN | LV_STATE_USER_4);
    lv_obj_set_style_bg_color(ui_Screen1, lv_color_hex(COLOR_BLUE_PRIMARY), LV_PART_MAIN | LV_STATE_USER_4);
    lv_obj_set_style_bg_opa(ui_Screen1, 255, LV_PART_MAIN | LV_STATE_USER_4);

    ui_SignalPanel = lv_obj_create(ui_Screen1);
    lv_obj_set_width(ui_SignalPanel, ui_sx(804));
    lv_obj_set_height(ui_SignalPanel, ui_sy(171));
    lv_obj_set_x(ui_SignalPanel, 0);
    lv_obj_set_y(ui_SignalPanel, ui_sy(-168));
    lv_obj_set_align(ui_SignalPanel, LV_ALIGN_CENTER);
    lv_obj_remove_flag(ui_SignalPanel, LV_OBJ_FLAG_SCROLLABLE); /// Flags
    lv_obj_set_style_radius(ui_SignalPanel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    // Create container for S-Meter segments (meter_parent)
    ui_SMeterSegmentsContainer = lv_obj_create(ui_Screen1);
    lv_obj_remove_style_all(ui_SMeterSegmentsContainer); // Remove default container styling
    lv_obj_add_flag(ui_SMeterSegmentsContainer, LV_OBJ_FLAG_OVERFLOW_VISIBLE); // Allow drawing outside bounds
    // Width and position will be set with common_meter_area_width and common_meter_area_x_pos
    lv_obj_set_height(ui_SMeterSegmentsContainer, LV_SIZE_CONTENT); // Height based on bar_height
    lv_obj_set_align(ui_SMeterSegmentsContainer, LV_ALIGN_TOP_LEFT);
    lv_obj_set_layout(ui_SMeterSegmentsContainer, LV_LAYOUT_FLEX);
    lv_obj_set_flex_flow(ui_SMeterSegmentsContainer, LV_FLEX_FLOW_ROW);
    // Align bars to the start, with a gap between them
    lv_obj_set_flex_align(ui_SMeterSegmentsContainer, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_coord_t bar_gap_px = ui_sx(2); // Gap between individual bars
    lv_obj_set_style_pad_column(ui_SMeterSegmentsContainer, bar_gap_px, 0);
    lv_obj_set_style_pad_left(ui_SMeterSegmentsContainer, 0, 0);
    lv_obj_set_style_pad_right(ui_SMeterSegmentsContainer, 0, 0);


    // Define "on" colors for 30 segments
    // Moved s_meter_on_colors to file scope, initialized here
    for (int k = 0; k < 30; k++) {
        if (k < 15) {
            // Segments 0-14 (S1 through S9)
            s_meter_on_colors[k] = lv_color_hex(COLOR_BLUE_METER_S_UNITS); // Blue
        } else {
            // Segments 15-29 (S9+20dB, S9+40dB, S9+60dB)
            s_meter_on_colors[k] = lv_color_hex(COLOR_RED_METER_HIGH); // Red
        }
    }

    lv_coord_t bar_width = ui_sx(7); // Increased width
    lv_coord_t bar_height = ui_sy(22); // Increased height

    // Initialize grid column descriptors with scaled bar_width
    for (int i = 0; i < 30; i++) grid_cols_30_scaled[i] = bar_width;
    grid_cols_30_scaled[30] = LV_GRID_TEMPLATE_LAST;

    // Define grid descriptors for meter label containers
    // static lv_coord_t grid_col_dsc[30 + 1]; // 30 segments + 1 for LV_GRID_TEMPLATE_LAST // REMOVED
    // for (int i = 0; i < 30; ++i) { // REMOVED
    //     grid_col_dsc[i] = bar_width; // Each column is the width of a bar segment // REMOVED
    // } // REMOVED
    // grid_col_dsc[30] = LV_GRID_TEMPLATE_LAST; // REMOVED

    static lv_coord_t grid_row_dsc[] = {LV_GRID_CONTENT, LV_GRID_TEMPLATE_LAST}; // Single row, height based on content

    // S-Meter segments creation moved to after positioning to prevent race condition

    ui_SMeterLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_SMeterLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_SMeterLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_x(ui_SMeterLabel, ui_sx(-374));
    lv_obj_set_y(ui_SMeterLabel, ui_sy(-194));
    lv_obj_set_align(ui_SMeterLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_SMeterLabel, "S");
    lv_obj_set_style_text_align(ui_SMeterLabel, LV_TEXT_ALIGN_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_SMeterLabel, ui_meter_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_Switch1 = lv_switch_create(ui_Screen1);
    lv_obj_set_width(ui_Switch1, ui_sx(50));
    lv_obj_set_height(ui_Switch1, ui_sy(25));
    lv_obj_set_x(ui_Switch1, ui_sx(346));
    lv_obj_set_y(ui_Switch1, ui_sy(219));
    lv_obj_set_align(ui_Switch1, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_Switch1, LV_OBJ_FLAG_HIDDEN); /// Flags

    ui_SwrMeterLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_SwrMeterLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_SwrMeterLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_x(ui_SwrMeterLabel, ui_sx(-374));
    lv_obj_set_y(ui_SwrMeterLabel, ui_sy(-140));
    lv_obj_set_align(ui_SwrMeterLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_SwrMeterLabel, "SWR");
    lv_obj_set_style_text_align(ui_SwrMeterLabel, LV_TEXT_ALIGN_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_SwrMeterLabel, ui_meter_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // Create container for SWR Meter segments
    ui_SwrMeterSegmentsContainer = lv_obj_create(ui_Screen1);
    lv_obj_remove_style_all(ui_SwrMeterSegmentsContainer);
    lv_obj_add_flag(ui_SwrMeterSegmentsContainer, LV_OBJ_FLAG_OVERFLOW_VISIBLE); // Allow drawing outside bounds
    lv_obj_set_height(ui_SwrMeterSegmentsContainer, LV_SIZE_CONTENT); // Height based on segments
    // Y position for SWR segments container (top edge)
    // Original bar was y=-140, align=center. Screen top Y = (480/2) - 140 = 100. Adjusted to 81.
    lv_obj_set_pos(ui_SwrMeterSegmentsContainer, 0, ui_sy(81)); // X will be set after width calculation, Y is top edge
    lv_obj_set_align(ui_SwrMeterSegmentsContainer, LV_ALIGN_TOP_LEFT); // Align to top-left for absolute positioning
    lv_obj_set_layout(ui_SwrMeterSegmentsContainer, LV_LAYOUT_FLEX);
    lv_obj_set_flex_flow(ui_SwrMeterSegmentsContainer, LV_FLEX_FLOW_ROW);
    // Align bars to the start, with a gap between them
    lv_obj_set_flex_align(ui_SwrMeterSegmentsContainer, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER,
                          LV_FLEX_ALIGN_CENTER);
    // bar_gap_px is defined earlier (e.g. 2px)
    lv_obj_set_style_pad_column(ui_SwrMeterSegmentsContainer, bar_gap_px, 0);
    lv_obj_set_style_pad_left(ui_SwrMeterSegmentsContainer, 0, 0);
    lv_obj_set_style_pad_right(ui_SwrMeterSegmentsContainer, 0, 0);

    // Create container for ALC Meter segments (Moved earlier)
    ui_AlcMeterSegmentsContainer = lv_obj_create(ui_Screen1);
    lv_obj_remove_style_all(ui_AlcMeterSegmentsContainer);
    lv_obj_add_flag(ui_AlcMeterSegmentsContainer, LV_OBJ_FLAG_OVERFLOW_VISIBLE); // Allow drawing outside bounds
    lv_obj_set_height(ui_AlcMeterSegmentsContainer, LV_SIZE_CONTENT); // Height based on segments
    lv_obj_set_align(ui_AlcMeterSegmentsContainer, LV_ALIGN_TOP_LEFT); // Align to top-left for absolute positioning
    lv_obj_set_layout(ui_AlcMeterSegmentsContainer, LV_LAYOUT_FLEX);
    lv_obj_set_flex_flow(ui_AlcMeterSegmentsContainer, LV_FLEX_FLOW_ROW);
    // Align bars to the start, with a gap between them
    lv_obj_set_flex_align(ui_AlcMeterSegmentsContainer, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER,
                          LV_FLEX_ALIGN_CENTER);
    // bar_gap_px is defined earlier (e.g. 2px)
    lv_obj_set_style_pad_column(ui_AlcMeterSegmentsContainer, bar_gap_px, 0);
    lv_obj_set_style_pad_left(ui_AlcMeterSegmentsContainer, 0, 0);
    lv_obj_set_style_pad_right(ui_AlcMeterSegmentsContainer, 0, 0);

    // Define "on" colors for 30 SWR segments
    // SWR > 3.0 (dot 19 / segment index 18 and above) should be red.
    // SWR <= 3.0 (dots 1-18 / segment indices 0-17) should be blue.
    // Moved swr_meter_on_colors to file scope, initialized here
    for (int k = 0; k < 30; k++) {
        if (k < 16) { // Segments 0-16 (dots 1-18) are blue
            swr_meter_on_colors[k] = lv_color_hex(COLOR_BLUE_METER_S_UNITS); // Blue
        } else { // Segments 18-29 (dots 19-30) are red
            swr_meter_on_colors[k] = lv_color_hex(COLOR_RED_METER_HIGH); // Red
        }
    }

    // Define fixed width and X position for meter areas
    // Width = 30 segments * bar_width + 29 gaps * bar_gap_px (recalculated from scaled values)
    lv_coord_t fixed_meter_area_width = 30 * bar_width + 29 * bar_gap_px;
    lv_coord_t label_container_extra_padding = ui_sx(50);
    lv_coord_t label_container_total_width = fixed_meter_area_width + label_container_extra_padding;
    // Original centering was effectively around X=195 on an 800px wide screen.
    lv_coord_t common_meter_area_x_pos = ui_sx(190) - (fixed_meter_area_width / 2) + ui_sx(5);

    lv_coord_t label_y_pos = ui_sy(10); // Y position for label containers (S-Meter ticks and Power scale)
    lv_coord_t meter_y_pos = ui_sy(35); // Y position for the S-Meter bar container

    // S-Meter container
    if (ui_SMeterSegmentsContainer) {
        lv_obj_set_width(ui_SMeterSegmentsContainer, fixed_meter_area_width);
        // Create children before setting position for LV_SIZE_CONTENT height
        create_meter_segments(ui_SMeterSegmentsContainer, ui_SMeterSegments, 30, bar_width, bar_height,
                              s_meter_on_colors);
        // Reduce animation time for S-Meter segments for snappier updates
        for (int i = 0; i < 30; i++) {
            if (ui_SMeterSegments[i] != NULL && lv_obj_is_valid(ui_SMeterSegments[i])) {
                lv_obj_set_style_anim_time(ui_SMeterSegments[i], 10, LV_PART_INDICATOR | LV_STATE_DEFAULT);
            }
        }
        lv_obj_set_pos(ui_SMeterSegmentsContainer, common_meter_area_x_pos, meter_y_pos);
    }

    // SWR Meter container: Y=89
    if (ui_SwrMeterSegmentsContainer) {
        lv_obj_set_width(ui_SwrMeterSegmentsContainer, fixed_meter_area_width);
        // Create children before setting position for LV_SIZE_CONTENT height
        create_meter_segments(ui_SwrMeterSegmentsContainer, ui_SwrMeterSegments, 30, bar_width, bar_height,
                              swr_meter_on_colors);
        // Reduce animation time for SWR Meter segments for snappier updates
        for (int i = 0; i < 30; i++) {
            if (ui_SwrMeterSegments[i] != NULL && lv_obj_is_valid(ui_SwrMeterSegments[i])) {
                lv_obj_set_style_anim_time(ui_SwrMeterSegments[i], 10, LV_PART_INDICATOR | LV_STATE_DEFAULT);
            }
        }
        lv_obj_set_pos(ui_SwrMeterSegmentsContainer, common_meter_area_x_pos, ui_sy(89));
    }

    // ALC Meter container: Y=62
    if (ui_AlcMeterSegmentsContainer) {
        lv_obj_set_width(ui_AlcMeterSegmentsContainer, fixed_meter_area_width);

        // Define "on" colors for 30 ALC segments immediately before use
        for (int k = 0; k < 30; k++) {
            if (k < 21) {
                // Segments 0-20
                alc_meter_on_colors[k] = lv_color_hex(COLOR_BLUE_METER_S_UNITS); // Blue
            } else {
                // Segments 21-29
                alc_meter_on_colors[k] = lv_color_hex(COLOR_RED_METER_HIGH); // Red
            }
        }

        // Create children before setting position for LV_SIZE_CONTENT height
        create_meter_segments(ui_AlcMeterSegmentsContainer, ui_AlcMeterSegments, 30, bar_width, bar_height,
                              alc_meter_on_colors);
        // Reduce animation time for ALC Meter segments for snappier updates
        for (int i = 0; i < 30; i++) {
            if (ui_AlcMeterSegments[i] != NULL && lv_obj_is_valid(ui_AlcMeterSegments[i])) {
                lv_obj_set_style_anim_time(ui_AlcMeterSegments[i], 10, LV_PART_INDICATOR | LV_STATE_DEFAULT);
            }
        }
        lv_obj_set_pos(ui_AlcMeterSegmentsContainer, common_meter_area_x_pos, ui_sy(62));
    }

    // Create container for S-Meter Tick Labels (for RX mode)
    ui_SMeterLabelsContainer = lv_obj_create(ui_Screen1);
    lv_obj_remove_style_all(ui_SMeterLabelsContainer);
    lv_obj_set_style_bg_color(ui_SMeterLabelsContainer, lv_color_hex(COLOR_BG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    // Match ui_SignalPanel theme color
    lv_obj_set_style_bg_opa(ui_SMeterLabelsContainer, LV_OPA_COVER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_add_flag(ui_SMeterLabelsContainer, LV_OBJ_FLAG_OVERFLOW_VISIBLE); // Restore for label visibility
    lv_obj_set_width(ui_SMeterLabelsContainer, label_container_total_width); // Use wider width to contain overflow
    lv_obj_set_height(ui_SMeterLabelsContainer, LV_SIZE_CONTENT); // Height based on font
    // lv_obj_move_background(ui_SMeterLabelsContainer); // Removed: visibility is handled by hide/show logic

    lv_obj_set_layout(ui_SMeterLabelsContainer, LV_LAYOUT_GRID);
    lv_obj_set_style_grid_column_dsc_array(ui_SMeterLabelsContainer, grid_cols_30_scaled, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_grid_row_dsc_array(ui_SMeterLabelsContainer, grid_row_dsc, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_column(ui_SMeterLabelsContainer, bar_gap_px, 0); // Set gaps between grid columns

    const char *s_meter_tick_texts[] = {"1", "3", "5", "7", "9", "20", "40", "60dB"};
    lv_font_t *s_meter_label_font = (lv_font_t *) ui_meter_font();
    float target_s_meter_segment_indices[] = {2.0f, 5.0f, 8.0f, 11.0f, 14.0f, 19.0f, 25.0f, 29.0f};
    const int num_s_meter_labels = 8;

    for (int i = 0; i < num_s_meter_labels; i++) {
        ui_SMeterTickLabels[i] = lv_label_create(ui_SMeterLabelsContainer);
        lv_label_set_text(ui_SMeterTickLabels[i], s_meter_tick_texts[i]);
        lv_obj_set_style_text_font(ui_SMeterTickLabels[i], s_meter_label_font, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_text_color(ui_SMeterTickLabels[i], lv_color_hex(COLOR_TEXT), LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_text_opa(ui_SMeterTickLabels[i], 255, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_width(ui_SMeterTickLabels[i], LV_SIZE_CONTENT); // Ensure label width is based on text

        uint8_t target_col = (uint8_t) roundf(target_s_meter_segment_indices[i]);

        if (i == num_s_meter_labels - 1) {
            // Last label ("60dB")
            // Revert to START alignment to keep original visual position; container width handles overflow.
            lv_obj_set_grid_cell(ui_SMeterTickLabels[i], LV_GRID_ALIGN_START, target_col, 1, LV_GRID_ALIGN_CENTER, 0,
                                 1);
            lv_obj_set_style_text_align(ui_SMeterTickLabels[i], LV_TEXT_ALIGN_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
        } else {
            lv_obj_set_grid_cell(ui_SMeterTickLabels[i], LV_GRID_ALIGN_CENTER, target_col, 1, LV_GRID_ALIGN_CENTER, 0,
                                 1);
            lv_obj_set_style_text_align(ui_SMeterTickLabels[i], LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
        }
    }
    // Position S-Meter labels above S-Meter segments using label_y_pos (10)
    // Children created, now set position for LV_SIZE_CONTENT height
    lv_obj_set_pos(ui_SMeterLabelsContainer, common_meter_area_x_pos, label_y_pos);
    lv_obj_set_align(ui_SMeterLabelsContainer, LV_ALIGN_TOP_LEFT);

    // Create container for SWR Tick Labels
    ui_SwrMeterLabelsContainer = lv_obj_create(ui_Screen1);
    lv_obj_remove_style_all(ui_SwrMeterLabelsContainer);
    lv_obj_set_width(ui_SwrMeterLabelsContainer, label_container_total_width);
    lv_obj_set_height(ui_SwrMeterLabelsContainer, LV_SIZE_CONTENT); // Height based on font

    // Set up grid layout for SWR labels (same pattern as S meter)
    lv_obj_set_layout(ui_SwrMeterLabelsContainer, LV_LAYOUT_GRID);
    lv_obj_set_style_grid_column_dsc_array(ui_SwrMeterLabelsContainer, grid_cols_30_scaled, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_grid_row_dsc_array(ui_SwrMeterLabelsContainer, grid_row_dsc, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_column(ui_SwrMeterLabelsContainer, bar_gap_px, 0); // Set gaps between grid columns

    // Create SWR tick labels with grid positioning
    const char *swr_meter_tick_texts[] = {"1", "1.5", "2", "3", "∞"};
    lv_font_t *swr_label_font = (lv_font_t *) ui_meter_font();
    float target_swr_segment_indices[] = {1.0f, 5.0f, 11.0f, 14.0f, 28.0f};
    const int num_swr_labels = 5;

    for (int i = 0; i < num_swr_labels; i++) {
        ui_SwrMeterTickLabels[i] = lv_label_create(ui_SwrMeterLabelsContainer);
        lv_label_set_text(ui_SwrMeterTickLabels[i], swr_meter_tick_texts[i]);
        lv_obj_set_style_text_font(ui_SwrMeterTickLabels[i], swr_label_font, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_text_color(ui_SwrMeterTickLabels[i], lv_color_hex(COLOR_TEXT),
                                    LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_text_opa(ui_SwrMeterTickLabels[i], 255, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_width(ui_SwrMeterTickLabels[i], LV_SIZE_CONTENT); // Ensure label width is based on text

        uint8_t target_col = (uint8_t) roundf(target_swr_segment_indices[i]);

        if (i == num_swr_labels - 1) {
            // Last label ("∞")
            lv_obj_set_grid_cell(ui_SwrMeterTickLabels[i], LV_GRID_ALIGN_START, target_col, 1, LV_GRID_ALIGN_CENTER, 0,
                                 1);
            lv_obj_set_style_text_align(ui_SwrMeterTickLabels[i], LV_TEXT_ALIGN_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
        } else {
            lv_obj_set_grid_cell(ui_SwrMeterTickLabels[i], LV_GRID_ALIGN_CENTER, target_col, 1, LV_GRID_ALIGN_CENTER, 0,
                                 1);
            lv_obj_set_style_text_align(ui_SwrMeterTickLabels[i], LV_TEXT_ALIGN_CENTER,
                                        LV_PART_MAIN | LV_STATE_DEFAULT);
        }
    }
    // Position SWR labels below SWR Meter Segments using grid layout (same as S meter)
    // SWR Meter Segments Y is 89, height is 22. End Y = 111.
    // SWR labels Y = 111 + 5px gap = 116.
    // Children created, now set position for LV_SIZE_CONTENT height
    lv_obj_set_pos(ui_SwrMeterLabelsContainer, common_meter_area_x_pos, ui_sy(116));
    lv_obj_set_align(ui_SwrMeterLabelsContainer, LV_ALIGN_TOP_LEFT);

    // --- Create container for Power Tick Labels (for TX mode scale) ---
    ui_PwrLabelsContainer = lv_obj_create(ui_Screen1);
    lv_obj_remove_style_all(ui_PwrLabelsContainer);
    lv_obj_set_style_bg_color(ui_PwrLabelsContainer, lv_color_hex(COLOR_BG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    // Match ui_SignalPanel theme color
    lv_obj_set_style_bg_opa(ui_PwrLabelsContainer, LV_OPA_COVER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_add_flag(ui_PwrLabelsContainer, LV_OBJ_FLAG_OVERFLOW_VISIBLE);
    lv_obj_set_width(ui_PwrLabelsContainer, label_container_total_width); // Use wider width to contain overflow
    lv_obj_set_height(ui_PwrLabelsContainer, LV_SIZE_CONTENT); // Height based on font
    lv_obj_add_flag(ui_PwrLabelsContainer, LV_OBJ_FLAG_HIDDEN); // Initially hidden, shown in TX mode

    lv_obj_set_layout(ui_PwrLabelsContainer, LV_LAYOUT_GRID);
    lv_obj_set_style_grid_column_dsc_array(ui_PwrLabelsContainer, grid_cols_30_scaled, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_grid_row_dsc_array(ui_PwrLabelsContainer, grid_row_dsc, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_column(ui_PwrLabelsContainer, bar_gap_px, 0);

    // Create Power tick labels
    const char *pwr_meter_tick_texts[] = {"5", "10", "25", "50", "100W"};
    lv_font_t *pwr_label_font = (lv_font_t *) ui_meter_font();
    float target_pwr_segment_indices[] = {2.0f, 5.0f, 11.0f, 17.0f, 29.0f};
    const int num_pwr_labels = 5;

    for (int i = 0; i < num_pwr_labels; i++) {
        ui_PwrTickLabels[i] = lv_label_create(ui_PwrLabelsContainer);
        lv_label_set_text(ui_PwrTickLabels[i], pwr_meter_tick_texts[i]);
        lv_obj_set_style_text_font(ui_PwrTickLabels[i], pwr_label_font, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_text_color(ui_PwrTickLabels[i], lv_color_hex(COLOR_TEXT), LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_style_text_opa(ui_PwrTickLabels[i], 255, LV_PART_MAIN | LV_STATE_DEFAULT);
        lv_obj_set_width(ui_PwrTickLabels[i], LV_SIZE_CONTENT);

        uint8_t target_col = (uint8_t) roundf(target_pwr_segment_indices[i]);

        if (i == num_pwr_labels - 1) {
            // Last label ("100W")
            // Align to the start of the cell, consistent with "60dB" and "∞" labels
            lv_obj_set_grid_cell(ui_PwrTickLabels[i], LV_GRID_ALIGN_START, target_col, 1, LV_GRID_ALIGN_CENTER, 0, 1);
            lv_obj_set_style_text_align(ui_PwrTickLabels[i], LV_TEXT_ALIGN_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
        } else {
            lv_obj_set_grid_cell(ui_PwrTickLabels[i], LV_GRID_ALIGN_CENTER, target_col, 1, LV_GRID_ALIGN_CENTER, 0, 1);
            lv_obj_set_style_text_align(ui_PwrTickLabels[i], LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
        }
    }
    // Children created, now set position for LV_SIZE_CONTENT height
    lv_obj_set_pos(ui_PwrLabelsContainer, common_meter_area_x_pos, label_y_pos); // Use common label_y_pos
    lv_obj_set_align(ui_PwrLabelsContainer, LV_ALIGN_TOP_LEFT);
    // The variable swr_text_label_width and its calculation block are no longer used for SWR/ALC container alignment.

    // ALC Meter
    ui_AlcLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_AlcLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_AlcLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_x(ui_AlcLabel, ui_sx(-374));
    lv_obj_set_y(ui_AlcLabel, ui_sy(-167));
    lv_obj_set_align(ui_AlcLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_AlcLabel, "ALC");
    lv_obj_set_style_text_align(ui_AlcLabel, LV_TEXT_ALIGN_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_AlcLabel, ui_meter_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // Old ui_SwrTextLabel positioning logic removed as it's replaced by ui_SwrMeterLabelsContainer.

    // Old ui_SwrTextLabel positioning logic removed as it's replaced by ui_SwrMeterLabelsContainer.

    // ALC meter segments creation moved to after positioning to prevent race condition // Note: Color init moved just before use.

    // AF/RF Gain bars - reduced width by 20% (105 -> 84), shifted right by 20px
    ui_AfGainBar = lv_bar_create(ui_Screen1);
    lv_bar_set_range(ui_AfGainBar, 0, 255); // Set range for AF Gain (0-255)
    lv_bar_set_value(ui_AfGainBar, 128, LV_ANIM_OFF); // Set an initial midrange value
    lv_bar_set_start_value(ui_AfGainBar, 0, LV_ANIM_OFF);
    lv_obj_set_width(ui_AfGainBar, ui_sx(84));
    lv_obj_set_height(ui_AfGainBar, ui_sy(10));
    lv_obj_set_x(ui_AfGainBar, ui_sx(361));
    lv_obj_set_y(ui_AfGainBar, ui_sy(-97));
    lv_obj_set_align(ui_AfGainBar, LV_ALIGN_CENTER);
    lv_obj_set_style_bg_color(ui_AfGainBar, lv_color_hex(COLOR_FG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_AfGainBar, lv_color_hex(COLOR_MINT), LV_PART_INDICATOR| LV_STATE_DEFAULT);
    lv_obj_set_style_anim_time(ui_AfGainBar, 50, LV_PART_INDICATOR | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_AfGainBar, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_AfGainBar, 0, LV_PART_INDICATOR | LV_STATE_DEFAULT);

    ui_AfGainLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_AfGainLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_AfGainLabel, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_AfGainLabel, ui_sx(299));
    lv_obj_set_y(ui_AfGainLabel, ui_sy(-98));
    lv_obj_set_align(ui_AfGainLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_AfGainLabel, "AF");
    lv_obj_set_style_text_font(ui_AfGainLabel, ui_font16(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_RfGainLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_RfGainLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_RfGainLabel, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_RfGainLabel, ui_sx(299));
    lv_obj_set_y(ui_RfGainLabel, ui_sy(-117));
    lv_obj_set_align(ui_RfGainLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_RfGainLabel, "RF");
    lv_obj_set_style_text_font(ui_RfGainLabel, ui_font16(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_RfGainBar = lv_bar_create(ui_Screen1);
    lv_bar_set_range(ui_RfGainBar, 0, 255); // Set range for RF Gain (0-255)
    lv_bar_set_value(ui_RfGainBar, 128, LV_ANIM_OFF); // Set an initial midrange value
    lv_bar_set_start_value(ui_RfGainBar, 0, LV_ANIM_OFF);
    lv_obj_set_width(ui_RfGainBar, ui_sx(84));
    lv_obj_set_height(ui_RfGainBar, ui_sy(10));
    lv_obj_set_x(ui_RfGainBar, ui_sx(361));
    lv_obj_set_y(ui_RfGainBar, ui_sy(-118));
    lv_obj_set_align(ui_RfGainBar, LV_ALIGN_CENTER);
    lv_obj_set_style_radius(ui_RfGainBar, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_RfGainBar, lv_color_hex(COLOR_FG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_RfGainBar, lv_color_hex(COLOR_MINT), LV_PART_INDICATOR| LV_STATE_DEFAULT);
    lv_obj_set_style_anim_time(ui_RfGainBar, 50, LV_PART_INDICATOR | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_RfGainBar, 0, LV_PART_INDICATOR | LV_STATE_DEFAULT);

    ui_VfoAValue = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_VfoAValue, ui_sx(600)); // Set a fixed width
    lv_obj_set_height(ui_VfoAValue, LV_SIZE_CONTENT); /// 1
    lv_obj_set_x(ui_VfoAValue, 0);
    lv_obj_set_y(ui_VfoAValue, ui_sy(45));
    lv_obj_set_align(ui_VfoAValue, LV_ALIGN_CENTER);
    lv_label_set_text(ui_VfoAValue, "14.012.000"); // Updated initial text
    lv_obj_set_style_text_align(ui_VfoAValue, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_VfoAValue, ui_freq_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_add_flag(ui_VfoAValue, LV_OBJ_FLAG_HIDDEN); // Hide old implementation during testing

    // Create segmented frequency display container
    ui_VfoAFreqContainer = lv_obj_create(ui_Screen1);
    lv_obj_set_size(ui_VfoAFreqContainer, ui_sx(600), LV_SIZE_CONTENT);
    lv_obj_set_flex_flow(ui_VfoAFreqContainer, LV_FLEX_FLOW_ROW);
    lv_obj_set_flex_align(ui_VfoAFreqContainer, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_set_style_border_width(ui_VfoAFreqContainer, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_VfoAFreqContainer, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_all(ui_VfoAFreqContainer, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    // Sets all paddings including column
    lv_obj_set_style_pad_column(ui_VfoAFreqContainer, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    // Explicitly set column padding to 0

    // Create MHz segment (e.g., "014")
    ui_VfoAFreqMHz = lv_label_create(ui_VfoAFreqContainer);
    lv_label_set_text(ui_VfoAFreqMHz, "14"); // Updated initial text
    lv_obj_set_style_text_font(ui_VfoAFreqMHz, ui_freq_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_VfoAFreqMHz, LV_TEXT_ALIGN_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_point_t label_size; // Renamed for generic use
    lv_txt_get_size(&label_size, "000", ui_freq_font(), 0, 0, LV_COORD_MAX, LV_TEXT_FLAG_NONE);
    lv_obj_set_width(ui_VfoAFreqMHz, label_size.x);

    // Create first period separator
    ui_VfoAFreqDot1 = lv_label_create(ui_VfoAFreqContainer);
    lv_label_set_text(ui_VfoAFreqDot1, ".");
    lv_obj_set_style_text_font(ui_VfoAFreqDot1, ui_freq_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_txt_get_size(&label_size, ".", ui_freq_font(), 0, 0, LV_COORD_MAX, LV_TEXT_FLAG_NONE);
    lv_obj_set_width(ui_VfoAFreqDot1, label_size.x);

    // Create kHz segment (e.g., "012")
    ui_VfoAFreqKHz = lv_label_create(ui_VfoAFreqContainer);
    lv_label_set_text(ui_VfoAFreqKHz, "012");
    lv_obj_set_style_text_font(ui_VfoAFreqKHz, ui_freq_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_VfoAFreqKHz, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_txt_get_size(&label_size, "000", ui_freq_font(), 0, 0, LV_COORD_MAX, LV_TEXT_FLAG_NONE);
    lv_obj_set_width(ui_VfoAFreqKHz, label_size.x);

    // Create second period separator
    ui_VfoAFreqDot2 = lv_label_create(ui_VfoAFreqContainer);
    lv_label_set_text(ui_VfoAFreqDot2, ".");
    lv_obj_set_style_text_font(ui_VfoAFreqDot2, ui_freq_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_txt_get_size(&label_size, ".", ui_freq_font(), 0, 0, LV_COORD_MAX, LV_TEXT_FLAG_NONE);
    lv_obj_set_width(ui_VfoAFreqDot2, label_size.x);

    // Create Hz segment (e.g., "00")
    ui_VfoAFreqHz = lv_label_create(ui_VfoAFreqContainer);
    lv_label_set_text(ui_VfoAFreqHz, "000"); // Updated initial text for 3 digits
    lv_obj_set_style_text_font(ui_VfoAFreqHz, ui_freq_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_VfoAFreqHz, LV_TEXT_ALIGN_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_txt_get_size(&label_size, "000", ui_freq_font(), 0, 0, LV_COORD_MAX, LV_TEXT_FLAG_NONE); // Measure "000"
    lv_obj_set_width(ui_VfoAFreqHz, label_size.x);

    // Children created, now set position for LV_SIZE_CONTENT height
    lv_obj_set_x(ui_VfoAFreqContainer, 0);
    lv_obj_set_y(ui_VfoAFreqContainer, ui_sy(45));
    lv_obj_set_align(ui_VfoAFreqContainer, LV_ALIGN_CENTER);

    // Mode label - displays current operating mode (USB, LSB, CW, etc.)
    ui_ModeLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_ModeLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_ModeLabel, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_ModeLabel, ui_sx(-121));
    lv_obj_set_y(ui_ModeLabel, ui_sy(-50));
    lv_obj_set_align(ui_ModeLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_ModeLabel, "USB");
    lv_obj_set_style_text_align(ui_ModeLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_ModeLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(ui_ModeLabel, lv_color_hex(COLOR_TEXT), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_ModeLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    // DATA mode label - appears next to mode dropdown when DATA mode is active
    ui_DataModeLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_DataModeLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_DataModeLabel, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_DataModeLabel, ui_sx(-55));
    lv_obj_set_y(ui_DataModeLabel, ui_sy(-50));
    lv_obj_set_align(ui_DataModeLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_DataModeLabel, "DATA");
    lv_obj_add_flag(ui_DataModeLabel, LV_OBJ_FLAG_HIDDEN); // Initially hidden
    lv_obj_set_style_text_align(ui_DataModeLabel, LV_TEXT_ALIGN_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_DataModeLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(ui_DataModeLabel, lv_color_hex(COLOR_TEXT), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_DataModeLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_VfoBValue = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_VfoBValue, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_VfoBValue, LV_SIZE_CONTENT); /// 1
    lv_obj_set_x(ui_VfoBValue, 0);
    lv_obj_set_y(ui_VfoBValue, ui_sy(123));
    lv_obj_set_align(ui_VfoBValue, LV_ALIGN_CENTER);
    lv_label_set_text(ui_VfoBValue, "14.014.100"); // Updated initial text
    lv_obj_add_flag(ui_VfoBValue, LV_OBJ_FLAG_HIDDEN); /// Flags
    lv_obj_set_style_text_align(ui_VfoBValue, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_VfoBValue, ui_freq_small_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_VfoAButtonBackground = lv_button_create(ui_Screen1);
    lv_obj_set_width(ui_VfoAButtonBackground, ui_sx(50));
    lv_obj_set_height(ui_VfoAButtonBackground, ui_sy(50));
    lv_obj_set_x(ui_VfoAButtonBackground, ui_sx(360));
    lv_obj_set_y(ui_VfoAButtonBackground, ui_sy(33));
    lv_obj_set_align(ui_VfoAButtonBackground, LV_ALIGN_CENTER);
    lv_obj_remove_flag(ui_VfoAButtonBackground, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE |
                      LV_OBJ_FLAG_GESTURE_BUBBLE |
                      LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                      LV_OBJ_FLAG_SCROLL_MOMENTUM |
                      LV_OBJ_FLAG_SCROLL_CHAIN)); /// Flags
    lv_obj_set_scrollbar_mode(ui_VfoAButtonBackground, LV_SCROLLBAR_MODE_OFF);
    lv_obj_set_style_radius(ui_VfoAButtonBackground, 5, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_VfoALabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_VfoALabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_VfoALabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_x(ui_VfoALabel, ui_sx(360));
    lv_obj_set_y(ui_VfoALabel, ui_sy(33));
    lv_obj_set_align(ui_VfoALabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_VfoALabel, "A");
    lv_obj_set_style_text_align(ui_VfoALabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_VfoALabel, ui_btn_large_bold_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_VfoALabel, 5, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_VfoALabel, lv_color_hex(COLOR_BLUE_VFO_A_CHECKED), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_opa(ui_VfoALabel, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_border_color(ui_VfoALabel, lv_color_hex(COLOR_BORDER), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_border_opa(ui_VfoALabel, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_radius(ui_VfoALabel, 5, LV_PART_MAIN | LV_STATE_USER_1);
    lv_obj_set_style_bg_color(ui_VfoALabel, lv_color_hex(COLOR_BLUE_PRIMARY), LV_PART_MAIN | LV_STATE_USER_1);
    lv_obj_set_style_bg_opa(ui_VfoALabel, 255, LV_PART_MAIN | LV_STATE_USER_1);

    ui_VfoBButtonBackground = lv_button_create(ui_Screen1);
    lv_obj_set_width(ui_VfoBButtonBackground, ui_sx(50));
    lv_obj_set_height(ui_VfoBButtonBackground, ui_sy(50));
    lv_obj_set_x(ui_VfoBButtonBackground, ui_sx(360));
    lv_obj_set_y(ui_VfoBButtonBackground, ui_sy(90));
    lv_obj_set_align(ui_VfoBButtonBackground, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_VfoBButtonBackground, LV_OBJ_FLAG_HIDDEN); /// Flags
    lv_obj_remove_flag(ui_VfoBButtonBackground, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE |
                      LV_OBJ_FLAG_GESTURE_BUBBLE |
                      LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                      LV_OBJ_FLAG_SCROLL_MOMENTUM |
                      LV_OBJ_FLAG_SCROLL_CHAIN)); /// Flags
    lv_obj_set_scrollbar_mode(ui_VfoBButtonBackground, LV_SCROLLBAR_MODE_OFF);
    lv_obj_set_style_radius(ui_VfoBButtonBackground, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_VfoBButtonBackground, 5, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_VfoBButtonBackground, lv_color_hex(COLOR_TEXT), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_opa(ui_VfoBButtonBackground, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_grad_color(ui_VfoBButtonBackground, lv_color_hex(COLOR_TEXT), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_border_color(ui_VfoBButtonBackground, lv_color_hex(COLOR_BORDER), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_border_opa(ui_VfoBButtonBackground, 255, LV_PART_MAIN | LV_STATE_CHECKED);

    ui_VfoBLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_VfoBLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_VfoBLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_x(ui_VfoBLabel, ui_sx(360));
    lv_obj_set_y(ui_VfoBLabel, ui_sy(90));
    lv_obj_set_align(ui_VfoBLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_VfoBLabel, "B");
    lv_obj_add_flag(ui_VfoBLabel, LV_OBJ_FLAG_CLICKABLE); /// Flags
    lv_obj_set_style_text_align(ui_VfoBLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_VfoBLabel, ui_btn_large_bold_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // Create Memory Label (shows "M" when in memory mode, positioned between A and B)
    ui_MemoryLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_MemoryLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_MemoryLabel, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_MemoryLabel, ui_sx(360));
    lv_obj_set_y(ui_MemoryLabel, ui_sy(60));
    lv_obj_set_align(ui_MemoryLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_MemoryLabel, "M");
    lv_obj_add_flag(ui_MemoryLabel, LV_OBJ_FLAG_HIDDEN);  // Hidden by default
    lv_obj_set_style_text_align(ui_MemoryLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_MemoryLabel, ui_btn_large_bold_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    // CHECKED state styling (same as VFO A) with padding for proper button appearance
    lv_obj_set_style_radius(ui_MemoryLabel, 5, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MemoryLabel, lv_color_hex(COLOR_BLUE_VFO_A_CHECKED), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_opa(ui_MemoryLabel, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_border_color(ui_MemoryLabel, lv_color_hex(COLOR_BORDER), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_border_opa(ui_MemoryLabel, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_pad_left(ui_MemoryLabel, ui_sx(12), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_pad_right(ui_MemoryLabel, ui_sx(12), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_pad_top(ui_MemoryLabel, 8, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_pad_bottom(ui_MemoryLabel, 8, LV_PART_MAIN | LV_STATE_CHECKED);

    // Create Memory Channel Label (shows "M.CH XX" next to antenna indicator)
    ui_MemoryChannelLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_MemoryChannelLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_MemoryChannelLabel, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_MemoryChannelLabel, ui_sx(-195));
    lv_obj_set_y(ui_MemoryChannelLabel, ui_sy(-50));
    lv_obj_set_align(ui_MemoryChannelLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_MemoryChannelLabel, "M.CH 00");
    lv_obj_add_flag(ui_MemoryChannelLabel, LV_OBJ_FLAG_HIDDEN);  // Hidden by default
    lv_obj_set_style_text_align(ui_MemoryChannelLabel, LV_TEXT_ALIGN_LEFT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_MemoryChannelLabel, ui_btn_small_med_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(ui_MemoryChannelLabel, lv_color_hex(0xFFFFFF), LV_PART_MAIN | LV_STATE_DEFAULT);

    // Create Antenna Container
    ui_AntennaSelectContainer = lv_obj_create(ui_Screen1);
    lv_obj_remove_style_all(ui_AntennaSelectContainer); // Remove default styles
    lv_obj_set_size(ui_AntennaSelectContainer, ui_sx(65), ui_sy(34));
    lv_obj_set_flex_flow(ui_AntennaSelectContainer, LV_FLEX_FLOW_ROW);
    lv_obj_set_flex_align(ui_AntennaSelectContainer, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    // Center items vertically
    lv_obj_set_style_pad_column(ui_AntennaSelectContainer, 5, 0); // Reduced gap to 5px

    // Create children for ui_AntennaSelectContainer first
    ui_AntSymbolLabel = lv_button_create(ui_AntennaSelectContainer);
    lv_obj_set_size(ui_AntSymbolLabel, LV_SIZE_CONTENT, LV_SIZE_CONTENT);

    lv_obj_remove_flag(ui_AntSymbolLabel, (lv_obj_flag_t)(LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE |
                                         LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM |
                                         LV_OBJ_FLAG_SCROLL_CHAIN));

    lv_obj_set_style_bg_opa(ui_AntSymbolLabel, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_width(ui_AntSymbolLabel, 0, LV_PART_MAIN | LV_STATE_DEFAULT); // Ensure no border either
    lv_obj_set_style_shadow_width(ui_AntSymbolLabel, 0, LV_PART_MAIN | LV_STATE_DEFAULT); // Ensure no shadow
    lv_obj_set_style_pad_all(ui_AntSymbolLabel, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    // Remove padding if background is gone

    // Add a label for the antenna symbol
    lv_obj_t *icon_label = lv_label_create(ui_AntSymbolLabel);
    lv_label_set_text(icon_label, "G");
    lv_obj_set_style_text_color(icon_label, lv_color_hex(COLOR_EMERALD_GREEN), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(icon_label, ui_glyph24_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_center(icon_label);

    // Create a container for Ant1Label and Ant2Label to make them overlap
    ui_AntNumIndicatorContainer = lv_obj_create(ui_AntennaSelectContainer);
    lv_obj_remove_style_all(ui_AntNumIndicatorContainer); // Remove default styles
    lv_obj_set_size(ui_AntNumIndicatorContainer, LV_SIZE_CONTENT, LV_SIZE_CONTENT); // Size to content

    // Modify ui_Ant1Label
    ui_Ant1Label = lv_label_create(ui_AntNumIndicatorContainer); // Parent is now ui_AntNumIndicatorContainer
    lv_obj_set_width(ui_Ant1Label, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_Ant1Label, LV_SIZE_CONTENT);
    lv_label_set_text(ui_Ant1Label, "1");
    lv_obj_remove_flag(ui_Ant1Label, (lv_obj_flag_t)(LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE |
                                    LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                                    LV_OBJ_FLAG_SCROLL_MOMENTUM |
                                    LV_OBJ_FLAG_SCROLL_CHAIN)); /// Flags
    lv_obj_set_style_text_align(ui_Ant1Label, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_Ant1Label, ui_btn_small_med_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(ui_Ant1Label, lv_color_hex(COLOR_EMERALD_GREEN), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_align(ui_Ant1Label, LV_ALIGN_CENTER, 0, 0); // Align to center of parent

    // Modify ui_Ant2Label
    ui_Ant2Label = lv_label_create(ui_AntNumIndicatorContainer); // Parent is now ui_AntNumIndicatorContainer
    lv_obj_set_width(ui_Ant2Label, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_Ant2Label, LV_SIZE_CONTENT);
    lv_label_set_text(ui_Ant2Label, "2");
    lv_obj_add_flag(ui_Ant2Label, LV_OBJ_FLAG_HIDDEN);
    lv_obj_remove_flag(ui_Ant2Label, (lv_obj_flag_t)(LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE |
                                    LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                                    LV_OBJ_FLAG_SCROLL_MOMENTUM |
                                    LV_OBJ_FLAG_SCROLL_CHAIN)); /// Flags
    lv_obj_set_style_text_align(ui_Ant2Label, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_Ant2Label, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(ui_Ant2Label, lv_color_hex(COLOR_EMERALD_GREEN), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_align(ui_Ant2Label, LV_ALIGN_CENTER, 0, 0); // Align to center of parent

    // Now position ui_AntennaSelectContainer after children are created
    // Manually set position as requested
    lv_obj_set_align(ui_AntennaSelectContainer, LV_ALIGN_CENTER);
    lv_obj_set_pos(ui_AntennaSelectContainer, ui_sx(-275), ui_sy(-50));

    ui_UtcTime = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_UtcTime, ui_sx(262));
    lv_obj_set_height(ui_UtcTime, ui_sy(70));
    lv_obj_set_x(ui_UtcTime, ui_sx(230));
    lv_obj_set_y(ui_UtcTime, ui_sy(-195));
    lv_obj_set_align(ui_UtcTime, LV_ALIGN_CENTER);

    lv_obj_remove_flag(ui_UtcTime, (lv_obj_flag_t)(LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE |
                                  LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE |
                                  LV_OBJ_FLAG_SCROLL_ELASTIC |
                                  LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN)); /// Flags
    lv_obj_set_style_text_color(ui_UtcTime, lv_color_hex(COLOR_TEXT), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_UtcTime, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_UtcTime, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT); // Changed to CENTER
    lv_obj_set_style_text_font(ui_UtcTime, ui_utc_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_UtcTime, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_UtcTime, lv_color_hex(COLOR_BG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_UtcTime, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_color(ui_UtcTime, lv_color_hex(COLOR_BORDER), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(ui_UtcTime, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_all(ui_UtcTime, 0, LV_PART_MAIN | LV_STATE_DEFAULT); // Ensure no padding


    ui_PwrLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_PwrLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_PwrLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_x(ui_PwrLabel, ui_sx(-374));
    lv_obj_set_y(ui_PwrLabel, ui_sy(-194));
    lv_obj_set_align(ui_PwrLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_PwrLabel, "PWR");
    lv_obj_add_flag(ui_PwrLabel, LV_OBJ_FLAG_HIDDEN); /// Flags
    lv_obj_remove_flag(ui_PwrLabel, (lv_obj_flag_t)(LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE |
                                   LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM |
                                   LV_OBJ_FLAG_SCROLL_CHAIN)); /// Flags
    lv_obj_set_style_text_align(ui_PwrLabel, LV_TEXT_ALIGN_RIGHT, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_PwrLabel, ui_meter_font(), LV_PART_MAIN | LV_STATE_DEFAULT);


    ui_IfFilter = lv_button_create(ui_Screen1);
    /* Fixed size avoids 0 × 0 during start-up */
    lv_obj_set_size(ui_IfFilter, ui_sx(70), ui_sy(45));
    lv_obj_set_x(ui_IfFilter, ui_sx(202));
    lv_obj_set_y(ui_IfFilter, ui_sy(-50));
    lv_obj_set_align(ui_IfFilter, LV_ALIGN_CENTER);
    lv_obj_remove_flag(ui_IfFilter, (lv_obj_flag_t)(LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE |
                                   LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    /// Flags
    lv_obj_set_style_radius(ui_IfFilter, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_IfFilter, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_IfFilterALabel = lv_label_create(ui_IfFilter);
    lv_obj_set_width(ui_IfFilterALabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_IfFilterALabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(ui_IfFilterALabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_IfFilterALabel, "");
    lv_obj_add_flag(ui_IfFilterALabel, LV_OBJ_FLAG_HIDDEN); /// Flags
    lv_obj_remove_flag(ui_IfFilterALabel, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE |
                      LV_OBJ_FLAG_SNAPPABLE |
                      LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM |
                      LV_OBJ_FLAG_SCROLL_CHAIN)); /// Flags
    lv_obj_set_style_text_align(ui_IfFilterALabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_IfFilterALabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_IfFilterBLabel = lv_label_create(ui_IfFilter);
    lv_obj_set_width(ui_IfFilterBLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_IfFilterBLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(ui_IfFilterBLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_IfFilterBLabel, "");
    lv_obj_add_flag(ui_IfFilterBLabel, LV_OBJ_FLAG_HIDDEN); /// Flags
    lv_obj_remove_flag(ui_IfFilterBLabel, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE |
                      LV_OBJ_FLAG_SNAPPABLE |
                      LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM |
                      LV_OBJ_FLAG_SCROLL_CHAIN)); /// Flags
    lv_obj_set_scrollbar_mode(ui_IfFilterBLabel, LV_SCROLLBAR_MODE_OFF);
    lv_obj_set_style_text_align(ui_IfFilterBLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_IfFilterBLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_RxTxLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_RxTxLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_RxTxLabel, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_RxTxLabel, ui_sx(-375));
    lv_obj_set_y(ui_RxTxLabel, ui_sy(-105));
    lv_obj_set_align(ui_RxTxLabel, LV_ALIGN_CENTER);

    lv_label_set_text(ui_RxTxLabel, "RX");
    lv_obj_add_flag(ui_RxTxLabel, LV_OBJ_FLAG_CLICKABLE); /// Flags
    lv_obj_set_scrollbar_mode(ui_RxTxLabel, LV_SCROLLBAR_MODE_OFF);
    lv_obj_set_style_text_color(ui_RxTxLabel, lv_color_hex(COLOR_TEXT), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_RxTxLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_RxTxLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_RxTxLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT); // Center text
    lv_obj_set_style_radius(ui_RxTxLabel, 5, 0);
    lv_obj_set_style_bg_color(ui_RxTxLabel, lv_color_hex(COLOR_GREEN_RX_ACTIVE), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_RxTxLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_left(ui_RxTxLabel, 3, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(ui_RxTxLabel, 3, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(ui_RxTxLabel, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(ui_RxTxLabel, 1, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(ui_RxTxLabel, lv_color_hex(COLOR_TEXT), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_text_opa(ui_RxTxLabel, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_text_font(ui_RxTxLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_CHECKED);
    // Use MeterFont for TX state
    lv_obj_set_style_text_align(ui_RxTxLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_CHECKED);
    // Center text for TX state
    lv_obj_set_style_bg_color(ui_RxTxLabel, lv_color_hex(COLOR_RED_TX_ACTIVE), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_opa(ui_RxTxLabel, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_pad_left(ui_RxTxLabel, 3, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_pad_right(ui_RxTxLabel, 3, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_pad_top(ui_RxTxLabel, 5, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_pad_bottom(ui_RxTxLabel, 1, LV_PART_MAIN | LV_STATE_CHECKED);

    // Create a column container for the left-side buttons
    ui_LeftButtonColumn = lv_obj_create(ui_Screen1);
    lv_obj_remove_style_all(ui_LeftButtonColumn); // Remove default padding/styles
    lv_obj_set_width(ui_LeftButtonColumn, ui_sx(70)); // Buttons are 70px wide
    lv_obj_set_height(ui_LeftButtonColumn, LV_SIZE_CONTENT); // Height based on content
    lv_obj_set_layout(ui_LeftButtonColumn, LV_LAYOUT_FLEX);
    lv_obj_set_flex_flow(ui_LeftButtonColumn, LV_FLEX_FLOW_COLUMN);
    // Align buttons to start (top) of column, centered horizontally within column
    lv_obj_set_flex_align(ui_LeftButtonColumn, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_set_style_pad_row(ui_LeftButtonColumn, ui_sy(10), 0); // 10px gap between buttons
    lv_obj_set_style_radius(ui_LeftButtonColumn, 5, 0);

    // --- Create children for LeftButtonColumn ---

    // --- NR Button ---
    ui_NrButton = lv_button_create(ui_LeftButtonColumn);
    lv_obj_set_width(ui_NrButton, ui_sx(70));
    lv_obj_set_height(ui_NrButton, ui_sy(40));
    lv_obj_set_flex_flow(ui_NrButton, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(ui_NrButton, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_add_flag(ui_NrButton, LV_OBJ_FLAG_CHECKABLE);
    lv_obj_remove_flag(ui_NrButton, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE |
                      LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    lv_obj_set_style_radius(ui_NrButton, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_NrButton, lv_color_hex(COLOR_BG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_NrButton, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_NrButton, 5, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_NrButton, lv_color_hex(COLOR_BLUE_PRIMARY), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_opa(ui_NrButton, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_radius(ui_NrButton, 5, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_color(ui_NrButton, lv_color_hex(COLOR_BLUE_PRIMARY),
                              LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_opa(ui_NrButton, 255, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    ui_NrButtonLabel = lv_label_create(ui_NrButton);
    lv_obj_set_width(ui_NrButtonLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_NrButtonLabel, LV_SIZE_CONTENT);
    lv_obj_set_align(ui_NrButtonLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_NrButtonLabel, "NR");
    lv_obj_remove_flag(ui_NrButtonLabel, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE |
                      LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                      LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    lv_obj_set_style_text_align(ui_NrButtonLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_NrButtonLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_add_event_cb(ui_NrButton, ui_event_NrButton, LV_EVENT_ALL, NULL);
    
    // Initialize NR button label
    update_nr_button_label();

    // --- NB Button ---
    ui_NbButton = lv_button_create(ui_LeftButtonColumn);
    lv_obj_set_width(ui_NbButton, ui_sx(70));
    lv_obj_set_height(ui_NbButton, ui_sy(40));
    lv_obj_set_flex_flow(ui_NbButton, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(ui_NbButton, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_add_flag(ui_NbButton, LV_OBJ_FLAG_CHECKABLE);
    lv_obj_remove_flag(ui_NbButton, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE |
                      LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    lv_obj_set_style_radius(ui_NbButton, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_NbButton, lv_color_hex(COLOR_BG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_NbButton, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_NbButton, 5, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_NbButton, lv_color_hex(COLOR_BLUE_PRIMARY), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_opa(ui_NbButton, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_radius(ui_NbButton, 5, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_color(ui_NbButton, lv_color_hex(COLOR_BLUE_PRIMARY),
                              LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_opa(ui_NbButton, 255, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    ui_NbButtonLabel = lv_label_create(ui_NbButton);
    lv_obj_set_width(ui_NbButtonLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_NbButtonLabel, LV_SIZE_CONTENT);
    lv_obj_set_align(ui_NbButtonLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_NbButtonLabel, "NB");
    lv_obj_remove_flag(ui_NbButtonLabel, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE |
                      LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                      LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    lv_obj_set_style_text_align(ui_NbButtonLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_NbButtonLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_add_event_cb(ui_NbButton, ui_event_NbButton, LV_EVENT_ALL, NULL);
    
    // Initialize NB button label
    update_nb_button_label();

    // --- PreAmp Button ---
    ui_PreAmpButton = lv_button_create(ui_LeftButtonColumn);
    lv_obj_set_width(ui_PreAmpButton, ui_sx(70));
    lv_obj_set_height(ui_PreAmpButton, ui_sy(40));
    lv_obj_set_flex_flow(ui_PreAmpButton, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(ui_PreAmpButton, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_add_flag(ui_PreAmpButton, LV_OBJ_FLAG_CHECKABLE);
    lv_obj_remove_flag(ui_PreAmpButton, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE |
                      LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    lv_obj_set_style_radius(ui_PreAmpButton, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_PreAmpButton, lv_color_hex(COLOR_BG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_PreAmpButton, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_PreAmpButton, 5, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_PreAmpButton, lv_color_hex(COLOR_BLUE_PRIMARY), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_opa(ui_PreAmpButton, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_radius(ui_PreAmpButton, 5, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_color(ui_PreAmpButton, lv_color_hex(COLOR_BLUE_PRIMARY),
                              LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_opa(ui_PreAmpButton, 255, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    ui_PreAmpButtonLabel = lv_label_create(ui_PreAmpButton);
    lv_obj_set_width(ui_PreAmpButtonLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_PreAmpButtonLabel, LV_SIZE_CONTENT);
    lv_obj_set_align(ui_PreAmpButtonLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_PreAmpButtonLabel, "PRE");
    lv_obj_remove_flag(ui_PreAmpButtonLabel, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE |
                      LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                      LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    lv_obj_set_style_text_align(ui_PreAmpButtonLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_PreAmpButtonLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_add_event_cb(ui_PreAmpButton, ui_event_PreAmpButton, LV_EVENT_ALL, NULL);

    // --- Proc Button ---
    ui_ProcButton = lv_button_create(ui_LeftButtonColumn);
    lv_obj_set_width(ui_ProcButton, ui_sx(70));
    lv_obj_set_height(ui_ProcButton, ui_sy(40));
    lv_obj_set_flex_flow(ui_ProcButton, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(ui_ProcButton, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_add_flag(ui_ProcButton, LV_OBJ_FLAG_CHECKABLE);
    lv_obj_remove_flag(ui_ProcButton, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE |
                      LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    lv_obj_set_style_radius(ui_ProcButton, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_ProcButton, lv_color_hex(COLOR_BG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_ProcButton, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_ProcButton, 5, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_ProcButton, lv_color_hex(COLOR_BLUE_PRIMARY), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_opa(ui_ProcButton, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_radius(ui_ProcButton, 5, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_color(ui_ProcButton, lv_color_hex(COLOR_BLUE_PRIMARY),
                              LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_opa(ui_ProcButton, 255, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    ui_ProcButtonLabel = lv_label_create(ui_ProcButton);
    lv_obj_set_width(ui_ProcButtonLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_ProcButtonLabel, LV_SIZE_CONTENT);
    lv_obj_set_align(ui_ProcButtonLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_ProcButtonLabel, "PROC");
    lv_obj_remove_flag(ui_ProcButtonLabel, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE |
                      LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                      LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    lv_obj_set_style_text_align(ui_ProcButtonLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_ProcButtonLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_add_event_cb(ui_ProcButton, ui_event_ProcButton, LV_EVENT_ALL, NULL);

    // --- AT Tune Button ---
    ui_AtTuneButton = lv_button_create(ui_LeftButtonColumn);
    lv_obj_set_width(ui_AtTuneButton, ui_sx(70));
    lv_obj_set_height(ui_AtTuneButton, ui_sy(40));
    lv_obj_set_flex_flow(ui_AtTuneButton, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(ui_AtTuneButton, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_add_flag(ui_AtTuneButton, LV_OBJ_FLAG_CHECKABLE);
    lv_obj_remove_flag(ui_AtTuneButton, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE |
                      LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    lv_obj_set_style_radius(ui_AtTuneButton, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_AtTuneButton, lv_color_hex(COLOR_BG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_AtTuneButton, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_AtTuneButton, 5, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_AtTuneButton, lv_color_hex(COLOR_BLUE_PRIMARY), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_opa(ui_AtTuneButton, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_radius(ui_AtTuneButton, 5, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_color(ui_AtTuneButton, lv_color_hex(COLOR_BLUE_PRIMARY),
                              LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_opa(ui_AtTuneButton, 255, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    ui_AtTuneButtonLabel = lv_label_create(ui_AtTuneButton);
    lv_obj_set_width(ui_AtTuneButtonLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_AtTuneButtonLabel, LV_SIZE_CONTENT);
    lv_obj_set_align(ui_AtTuneButtonLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_AtTuneButtonLabel, "AT");
    lv_obj_remove_flag(ui_AtTuneButtonLabel, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE |
                      LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                      LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    lv_obj_set_style_text_align(ui_AtTuneButtonLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_AtTuneButtonLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_add_event_cb(ui_AtTuneButton, ui_event_AtTuneButton, LV_EVENT_ALL, NULL);

    // --- ATT Button ---
    ui_AttButton = lv_button_create(ui_LeftButtonColumn);
    lv_obj_set_width(ui_AttButton, ui_sx(70));
    lv_obj_set_height(ui_AttButton, ui_sy(40));
    lv_obj_set_flex_flow(ui_AttButton, LV_FLEX_FLOW_COLUMN);
    lv_obj_set_flex_align(ui_AttButton, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_add_flag(ui_AttButton, LV_OBJ_FLAG_CHECKABLE);
    lv_obj_remove_flag(ui_AttButton, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE |
                      LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    lv_obj_set_style_radius(ui_AttButton, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_AttButton, lv_color_hex(COLOR_BG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_AttButton, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_AttButton, 5, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_AttButton, lv_color_hex(COLOR_BLUE_PRIMARY), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_opa(ui_AttButton, 255, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_radius(ui_AttButton, 5, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_color(ui_AttButton, lv_color_hex(COLOR_BLUE_PRIMARY),
                              LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_opa(ui_AttButton, 255, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    ui_AttButtonLabel = lv_label_create(ui_AttButton);
    lv_obj_set_width(ui_AttButtonLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_AttButtonLabel, LV_SIZE_CONTENT);
    lv_obj_set_align(ui_AttButtonLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_AttButtonLabel, "ATT");
    lv_obj_remove_flag(ui_AttButtonLabel, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE |
                      LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                      LV_OBJ_FLAG_SCROLL_MOMENTUM | LV_OBJ_FLAG_SCROLL_CHAIN));
    lv_obj_set_style_text_align(ui_AttButtonLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_AttButtonLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_add_event_cb(ui_AttButton, ui_event_AttButton, LV_EVENT_ALL, NULL);

    // --- Position LeftButtonColumn now that children are created ---
    lv_obj_set_x(ui_LeftButtonColumn, ui_sx(-360));
    lv_obj_set_y(ui_LeftButtonColumn, ui_sy(80));
    lv_obj_set_align(ui_LeftButtonColumn, LV_ALIGN_CENTER);

    ui_IncreaseSwrButton = lv_button_create(ui_Screen1);
    lv_obj_set_width(ui_IncreaseSwrButton, ui_sx(78));
    lv_obj_set_height(ui_IncreaseSwrButton, ui_sy(37));
    lv_obj_set_x(ui_IncreaseSwrButton, ui_sx(-226));
    lv_obj_set_y(ui_IncreaseSwrButton, ui_sy(211));
    lv_obj_set_align(ui_IncreaseSwrButton, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_IncreaseSwrButton, (lv_obj_flag_t)(LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_SCROLL_ON_FOCUS)); /// Flags
    lv_obj_remove_flag(ui_IncreaseSwrButton, LV_OBJ_FLAG_SCROLLABLE); /// Flags
    lv_obj_set_style_radius(ui_IncreaseSwrButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_IncreaseSwrButton, ui_font16(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_IncreaseSwrLabel = lv_label_create(ui_IncreaseSwrButton);
    lv_obj_set_width(ui_IncreaseSwrLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_IncreaseSwrLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_x(ui_IncreaseSwrLabel, 0);
    lv_obj_set_y(ui_IncreaseSwrLabel, -1);
    lv_obj_set_align(ui_IncreaseSwrLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_IncreaseSwrLabel, "INC SWR");
    lv_label_set_recolor(ui_IncreaseSwrLabel, "true");

    ui_DecreaseSwrButton = lv_button_create(ui_Screen1);
    lv_obj_set_width(ui_DecreaseSwrButton, ui_sx(78));
    lv_obj_set_height(ui_DecreaseSwrButton, ui_sy(37));
    lv_obj_set_x(ui_DecreaseSwrButton, ui_sx(-138));
    lv_obj_set_y(ui_DecreaseSwrButton, ui_sy(210));
    lv_obj_set_align(ui_DecreaseSwrButton, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_DecreaseSwrButton, (lv_obj_flag_t)(LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_SCROLL_ON_FOCUS)); /// Flags
    lv_obj_remove_flag(ui_DecreaseSwrButton, LV_OBJ_FLAG_SCROLLABLE); /// Flags
    lv_obj_set_style_radius(ui_DecreaseSwrButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_DecreaseSwrLabel = lv_label_create(ui_DecreaseSwrButton);
    lv_obj_set_width(ui_DecreaseSwrLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_DecreaseSwrLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(ui_DecreaseSwrLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_DecreaseSwrLabel, "DEC SWR");
    lv_obj_set_style_text_font(ui_DecreaseSwrLabel, ui_font16(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_IncreaseSMeterButton = lv_button_create(ui_Screen1);
    lv_obj_set_width(ui_IncreaseSMeterButton, ui_sx(78));
    lv_obj_set_height(ui_IncreaseSMeterButton, ui_sy(37));
    lv_obj_set_x(ui_IncreaseSMeterButton, ui_sx(-50));
    lv_obj_set_y(ui_IncreaseSMeterButton, ui_sy(210));
    lv_obj_set_align(ui_IncreaseSMeterButton, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_IncreaseSMeterButton, (lv_obj_flag_t)(LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_SCROLL_ON_FOCUS)); /// Flags
    lv_obj_remove_flag(ui_IncreaseSMeterButton, LV_OBJ_FLAG_SCROLLABLE); /// Flags
    lv_obj_set_style_radius(ui_IncreaseSMeterButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_IncreaseSMeterLabel = lv_label_create(ui_IncreaseSMeterButton);
    lv_obj_set_width(ui_IncreaseSMeterLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_IncreaseSMeterLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(ui_IncreaseSMeterLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_IncreaseSMeterLabel, "INC SM");
    lv_obj_set_style_text_font(ui_IncreaseSMeterLabel, ui_font16(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_DecreaseSMeterButton = lv_button_create(ui_Screen1);
    lv_obj_set_width(ui_DecreaseSMeterButton, ui_sx(78));
    lv_obj_set_height(ui_DecreaseSMeterButton, ui_sy(37));
    lv_obj_set_x(ui_DecreaseSMeterButton, ui_sx(40));
    lv_obj_set_y(ui_DecreaseSMeterButton, ui_sy(210));
    lv_obj_set_align(ui_DecreaseSMeterButton, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_DecreaseSMeterButton, (lv_obj_flag_t)(LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_SCROLL_ON_FOCUS)); /// Flags
    lv_obj_remove_flag(ui_DecreaseSMeterButton, LV_OBJ_FLAG_SCROLLABLE); /// Flags
    lv_obj_set_style_radius(ui_DecreaseSMeterButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_DecreaseSMeterLabel = lv_label_create(ui_DecreaseSMeterButton);
    lv_obj_set_width(ui_DecreaseSMeterLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_DecreaseSMeterLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(ui_DecreaseSMeterLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_DecreaseSMeterLabel, "DEC SM");
    lv_obj_set_style_text_font(ui_DecreaseSMeterLabel, ui_font16(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_SplitButton = lv_button_create(ui_Screen1);
    lv_obj_set_width(ui_SplitButton, ui_sx(70));
    lv_obj_set_height(ui_SplitButton, ui_sy(45));
    lv_obj_set_x(ui_SplitButton, ui_sx(360));
    lv_obj_set_y(ui_SplitButton, ui_sy(-30));
    lv_obj_set_align(ui_SplitButton, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_SplitButton, (lv_obj_flag_t)(LV_OBJ_FLAG_CHECKABLE | LV_OBJ_FLAG_HIDDEN)); /// Flags - Initially hidden until split mode is active
    lv_obj_remove_flag(ui_SplitButton, (lv_obj_flag_t)(LV_OBJ_FLAG_GESTURE_BUBBLE | LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE |
                                      LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM |
                                      LV_OBJ_FLAG_SCROLL_CHAIN)); /// Flags
    lv_obj_set_style_radius(ui_SplitButton, 5, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_SplitButton, lv_color_hex(COLOR_BG_DARK_GRAY_BUTTON), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_SplitButton, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_radius(ui_SplitButton, 5, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_SplitButton, lv_color_hex(COLOR_BLUE_PRIMARY), LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_bg_opa(ui_SplitButton, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_CHECKED);
    lv_obj_set_style_radius(ui_SplitButton, 5, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_color(ui_SplitButton, lv_color_hex(COLOR_BLUE_PRIMARY),
                              LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);
    lv_obj_set_style_bg_opa(ui_SplitButton, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_CHECKED | LV_STATE_PRESSED);

    ui_SplitButtonLabel = lv_label_create(ui_SplitButton);
    lv_obj_set_width(ui_SplitButtonLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_SplitButtonLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(ui_SplitButtonLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_SplitButtonLabel, "SPLIT");
    lv_obj_remove_flag(ui_SplitButtonLabel, (lv_obj_flag_t)(
                      LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE |
                      LV_OBJ_FLAG_SNAPPABLE |
                      LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM |
                      LV_OBJ_FLAG_SCROLL_CHAIN)); /// Flags
    lv_obj_set_style_text_align(ui_SplitButtonLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_SplitButtonLabel, lv_color_hex(COLOR_TEXT), LV_PART_MAIN | LV_STATE_PRESSED);
    lv_obj_set_style_bg_opa(ui_SplitButtonLabel, 255, LV_PART_MAIN | LV_STATE_PRESSED);

    // Original NrButton creation code removed, it's now in LeftButtonColumn

    // XVTR label - displays transverter status between Mode and AGC
    ui_XvtrLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_XvtrLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_XvtrLabel, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_XvtrLabel, ui_sx(20));
    lv_obj_set_y(ui_XvtrLabel, ui_sy(-50));
    lv_obj_set_align(ui_XvtrLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_XvtrLabel, "XVTR");
    lv_obj_add_flag(ui_XvtrLabel, LV_OBJ_FLAG_HIDDEN);  // Hidden by default
    lv_obj_set_style_text_font(ui_XvtrLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_color(ui_XvtrLabel, lv_color_hex(COLOR_TEXT), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_XvtrLabel, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_AgcLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_AgcLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_AgcLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_x(ui_AgcLabel, ui_sx(120));
    lv_obj_set_y(ui_AgcLabel, ui_sy(-50));
    lv_obj_set_align(ui_AgcLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_AgcLabel, "AGC-?");
    lv_obj_set_style_text_font(ui_AgcLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // Notch filter indicator label - positioned to the right of AGC label
    ui_NotchLabel = lv_label_create(ui_Screen1);
    lv_obj_set_width(ui_NotchLabel, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_NotchLabel, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_NotchLabel, ui_sx(200));
    lv_obj_set_y(ui_NotchLabel, ui_sy(-50));
    lv_obj_set_align(ui_NotchLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_NotchLabel, "NCH-A");  // Default text, will be updated
    lv_obj_add_flag(ui_NotchLabel, LV_OBJ_FLAG_HIDDEN);  // Hidden by default (notch off)
    lv_obj_set_style_text_font(ui_NotchLabel, ui_btn_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // RIT container - left of SPLIT button (X:360, Y:-50)
    // Contains "RIT" label and value, visibility controlled by container
    ui_RitContainer = lv_obj_create(ui_Screen1);
    lv_obj_set_width(ui_RitContainer, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_RitContainer, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_RitContainer, ui_sx(225));
    lv_obj_set_y(ui_RitContainer, ui_sy(-55));
    lv_obj_set_align(ui_RitContainer, LV_ALIGN_CENTER);
    lv_obj_set_flex_flow(ui_RitContainer, LV_FLEX_FLOW_ROW);
    lv_obj_set_flex_align(ui_RitContainer, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_set_style_pad_column(ui_RitContainer, 4, 0);  // 4px gap between label and value
    lv_obj_set_style_pad_all(ui_RitContainer, 0, 0);
    lv_obj_set_style_bg_opa(ui_RitContainer, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(ui_RitContainer, 0, 0);
    lv_obj_add_flag(ui_RitContainer, LV_OBJ_FLAG_HIDDEN);
    lv_obj_remove_flag(ui_RitContainer, LV_OBJ_FLAG_SCROLLABLE);

    ui_RitLabel = lv_label_create(ui_RitContainer);
    lv_label_set_text(ui_RitLabel, "RIT");
    lv_obj_set_style_text_font(ui_RitLabel, ui_btn_small_reg_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_RitValue = lv_label_create(ui_RitContainer);
    lv_label_set_text(ui_RitValue, "+0.00");
    lv_obj_set_style_text_font(ui_RitValue, ui_btn_small_reg_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // XIT container - right of SPLIT button
    ui_XitContainer = lv_obj_create(ui_Screen1);
    lv_obj_set_width(ui_XitContainer, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_XitContainer, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_XitContainer, ui_sx(325));
    lv_obj_set_y(ui_XitContainer, ui_sy(-55));
    lv_obj_set_align(ui_XitContainer, LV_ALIGN_CENTER);
    lv_obj_set_flex_flow(ui_XitContainer, LV_FLEX_FLOW_ROW);
    lv_obj_set_flex_align(ui_XitContainer, LV_FLEX_ALIGN_START, LV_FLEX_ALIGN_CENTER, LV_FLEX_ALIGN_CENTER);
    lv_obj_set_style_pad_column(ui_XitContainer, 4, 0);  // 4px gap between label and value
    lv_obj_set_style_pad_all(ui_XitContainer, 0, 0);
    lv_obj_set_style_bg_opa(ui_XitContainer, LV_OPA_TRANSP, 0);
    lv_obj_set_style_border_width(ui_XitContainer, 0, 0);
    lv_obj_add_flag(ui_XitContainer, LV_OBJ_FLAG_HIDDEN);
    lv_obj_remove_flag(ui_XitContainer, LV_OBJ_FLAG_SCROLLABLE);

    ui_XitLabel = lv_label_create(ui_XitContainer);
    lv_label_set_text(ui_XitLabel, "XIT");
    lv_obj_set_style_text_font(ui_XitLabel, ui_btn_small_reg_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_XitValue = lv_label_create(ui_XitContainer);
    lv_label_set_text(ui_XitValue, "+0.00");
    lv_obj_set_style_text_font(ui_XitValue, ui_btn_small_reg_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    // Original NbButton creation code removed, it's now in LeftButtonColumn
    ui_DebugMode = lv_button_create(ui_Screen1);
    lv_obj_set_width(ui_DebugMode, ui_sx(78));
    lv_obj_set_height(ui_DebugMode, ui_sy(37));
    lv_obj_set_x(ui_DebugMode, ui_sx(347));
    lv_obj_set_y(ui_DebugMode, ui_sy(167));
    lv_obj_set_align(ui_DebugMode, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_DebugMode, (lv_obj_flag_t)(LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_SCROLL_ON_FOCUS)); /// Flags
    lv_obj_remove_flag(ui_DebugMode, LV_OBJ_FLAG_SCROLLABLE); /// Flags
    lv_obj_set_style_radius(ui_DebugMode, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_DebugMode, ui_font16(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_DebugModeButtonLabel = lv_label_create(ui_DebugMode);
    lv_obj_set_width(ui_DebugModeButtonLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_DebugModeButtonLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_x(ui_DebugModeButtonLabel, 0);
    lv_obj_set_y(ui_DebugModeButtonLabel, -1);
    lv_obj_set_align(ui_DebugModeButtonLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_DebugModeButtonLabel, "DEBUG");
    lv_label_set_recolor(ui_DebugModeButtonLabel, "true");
    lv_obj_set_style_text_align(ui_DebugModeButtonLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_SettingsButton = lv_button_create(ui_Screen1);
    lv_obj_set_width(ui_SettingsButton, ui_sx(70));
    lv_obj_set_height(ui_SettingsButton, ui_sy(40));
    lv_obj_set_x(ui_SettingsButton, ui_sx(370));
    lv_obj_set_y(ui_SettingsButton, ui_sy(-210));
    lv_obj_set_align(ui_SettingsButton, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_SettingsButton, LV_OBJ_FLAG_SCROLL_ON_FOCUS); /// Flags
    lv_obj_remove_flag(ui_SettingsButton, LV_OBJ_FLAG_SCROLLABLE); /// Flags
    lv_obj_set_style_radius(ui_SettingsButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_SettingsButton, lv_color_hex(COLOR_BG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_opa(ui_SettingsButton, 255, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_SettingsButtonLabel = lv_label_create(ui_SettingsButton);
    lv_obj_set_width(ui_SettingsButtonLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_SettingsButtonLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(ui_SettingsButtonLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_SettingsButtonLabel, LV_SYMBOL_SETTINGS);
    lv_obj_set_style_text_font(ui_SettingsButtonLabel, &lv_font_montserrat_36, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_SettingsButtonLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_CatConnectedButton = lv_button_create(ui_Screen1);
    lv_obj_set_width(ui_CatConnectedButton, ui_sx(50));
    lv_obj_set_height(ui_CatConnectedButton, ui_sy(50));
    lv_obj_set_x(ui_CatConnectedButton, ui_sx(370));
    lv_obj_set_y(ui_CatConnectedButton, ui_sy(-155));
    lv_obj_set_align(ui_CatConnectedButton, LV_ALIGN_CENTER); // Align to center
    lv_obj_add_flag(ui_CatConnectedButton, LV_OBJ_FLAG_SCROLL_ON_FOCUS); /// Flags
    lv_obj_remove_flag(ui_CatConnectedButton, LV_OBJ_FLAG_SCROLLABLE); /// Flags
    // lv_obj_add_flag(ui_CatConnectedButton, LV_OBJ_FLAG_HIDDEN); // Initially hidden - REMOVED, button is now always visible
    lv_obj_set_style_radius(ui_CatConnectedButton, 0, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_CatConnectedButton, lv_color_hex(COLOR_BG_DARK), LV_PART_MAIN | LV_STATE_DEFAULT);
    // Keep color for potential future use
    lv_obj_set_style_bg_opa(ui_CatConnectedButton, LV_OPA_TRANSP, LV_PART_MAIN | LV_STATE_DEFAULT);
    // Make background transparent

    ui_CatConnectedLabel = lv_label_create(ui_CatConnectedButton);
    lv_obj_set_width(ui_CatConnectedLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_height(ui_CatConnectedLabel, LV_SIZE_CONTENT); /// 1
    lv_obj_set_align(ui_CatConnectedLabel, LV_ALIGN_CENTER);
    lv_label_set_text(ui_CatConnectedLabel, "I"); // Initial state: "Disconnected"
    lv_obj_set_style_text_font(ui_CatConnectedLabel, ui_glyph30_font(), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_align(ui_CatConnectedLabel, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);

    // Create Filter USB Container
    ui_FilterUsbContainer = lv_obj_create(ui_Screen1);
    lv_obj_remove_style_all(ui_FilterUsbContainer);
    lv_obj_set_width(ui_FilterUsbContainer, ui_sx(147));
    lv_obj_set_height(ui_FilterUsbContainer, ui_sy(90));
    lv_obj_set_x(ui_FilterUsbContainer, ui_sx(186));
    lv_obj_set_y(ui_FilterUsbContainer, ui_sy(-130));
    lv_obj_set_align(ui_FilterUsbContainer, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_FilterUsbContainer, LV_OBJ_FLAG_HIDDEN);     /// Flags
    lv_obj_remove_flag(ui_FilterUsbContainer, (lv_obj_flag_t)(LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE));      /// Flags

    ui_FilterGlyph = lv_label_create(ui_FilterUsbContainer);
    lv_obj_set_width(ui_FilterGlyph, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_FilterGlyph, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_FilterGlyph, -1);
    lv_obj_set_y(ui_FilterGlyph, -4);
    lv_obj_set_align(ui_FilterGlyph, LV_ALIGN_CENTER);
    lv_label_set_text(ui_FilterGlyph, "C");
    lv_obj_set_style_text_color(ui_FilterGlyph, lv_color_hex(0xE667DE), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_FilterGlyph, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_FilterGlyph, ui_glyph70_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_Low = lv_label_create(ui_FilterUsbContainer);
    lv_obj_set_width(ui_Low, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_Low, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_Low, ui_sx(-29));
    lv_obj_set_y(ui_Low, ui_sy(35));
    lv_obj_set_align(ui_Low, LV_ALIGN_CENTER);
    lv_label_set_text(ui_Low, "200");
    lv_obj_set_style_text_font(ui_Low, ui_btn_small_med_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_High = lv_label_create(ui_FilterUsbContainer);
    lv_obj_set_width(ui_High, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_High, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_High, ui_sx(29));
    lv_obj_set_y(ui_High, ui_sy(35));
    lv_obj_set_align(ui_High, LV_ALIGN_CENTER);
    lv_label_set_text(ui_High, "2400");
    lv_obj_set_style_text_font(ui_High, ui_btn_small_med_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_CwFilterContainer = lv_obj_create(ui_Screen1);
    lv_obj_remove_style_all(ui_CwFilterContainer);
    lv_obj_set_width(ui_CwFilterContainer, ui_sx(147));
    lv_obj_set_height(ui_CwFilterContainer, ui_sy(90));
    lv_obj_set_x(ui_CwFilterContainer, ui_sx(186));
    lv_obj_set_y(ui_CwFilterContainer, ui_sy(-130));
    lv_obj_set_align(ui_CwFilterContainer, LV_ALIGN_CENTER);
    lv_obj_add_flag(ui_CwFilterContainer, LV_OBJ_FLAG_HIDDEN);     /// Flags
    lv_obj_remove_flag(ui_CwFilterContainer, (lv_obj_flag_t)(LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE));      /// Flags

    ui_CwFilterModeGlyph = lv_label_create(ui_CwFilterContainer);
    lv_obj_set_width(ui_CwFilterModeGlyph, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_CwFilterModeGlyph, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_CwFilterModeGlyph, 0);
    lv_obj_set_y(ui_CwFilterModeGlyph, -5);
    lv_obj_set_align(ui_CwFilterModeGlyph, LV_ALIGN_CENTER);
    lv_label_set_text(ui_CwFilterModeGlyph, "D");
    lv_obj_set_style_text_color(ui_CwFilterModeGlyph, lv_color_hex(0xE667DE), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_opa(ui_CwFilterModeGlyph, 255, LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_text_font(ui_CwFilterModeGlyph, ui_glyph70_font(), LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_CwFilterWidth = lv_label_create(ui_CwFilterContainer);
    lv_obj_set_width(ui_CwFilterWidth, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_CwFilterWidth, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_CwFilterWidth, 0);
    lv_obj_set_y(ui_CwFilterWidth, ui_sy(35));
    lv_obj_set_align(ui_CwFilterWidth, LV_ALIGN_CENTER);
    lv_label_set_text(ui_CwFilterWidth, "350");
    lv_obj_set_style_text_font(ui_CwFilterWidth, ui_btn_small_med_font(), LV_PART_MAIN | LV_STATE_DEFAULT);


    lv_obj_add_event_cb(ui_Switch1, ui_event_Switch1, LV_EVENT_ALL, NULL);
    // Removed: Mode is now a display-only label, not interactive
    // lv_obj_add_event_cb(ui_ModeLabel, ui_event_ModeDropDown, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_AntSymbolLabel, ui_event_changeAntenna, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_UtcTime, ui_event_UtcTime, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_IfFilter, ui_event_IfFilter, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_RxTxLabel, ui_event_RxTxLabel, LV_EVENT_ALL, NULL);
    // Event callbacks for PreAmpButton, AttButton, AtTuneButton, ProcButton, NrButton, NbButton
    // are now added when the buttons are created within ui_LeftButtonColumn.
    lv_obj_add_event_cb(ui_IncreaseSwrLabel, ui_event_IncreaseSwrLabel, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_IncreaseSwrButton, ui_event_IncreaseSwrButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_DecreaseSwrButton, ui_event_DecreaseSwrButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_IncreaseSMeterButton, ui_event_IncreaseSMeterButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_DecreaseSMeterButton, ui_event_DecreaseSMeterButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_SplitButton, ui_event_SplitButton, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_DebugMode, ui_event_DebugMode, LV_EVENT_ALL, NULL);
    lv_obj_add_event_cb(ui_SettingsButton, ui_event_SettingsButton, LV_EVENT_ALL, NULL);

    // Initialize RX/TX label status
    // The update_rxtx_label_status function itself now contains lv_obj_is_valid checks for its UI elements.
    // We still need to ensure ui_RxTxLabel is valid before calling.
    if (lv_obj_is_valid(ui_RxTxLabel)) {
        update_rxtx_label_status(cat_get_transmit_status());
    }

    // Register LVGL 9 subject observers for ui_Screen1
    if (lv_obj_is_valid(ui_Screen1)) {
        // VFO consolidated updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_vfo_consolidated_subject, update_vfo_consolidated_observer_cb, ui_Screen1, NULL);

        // S-Meter updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_s_meter_subject, update_s_meter_observer_cb, ui_Screen1, NULL);

        // Mode updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_mode_subject, update_mode_observer_cb, ui_Screen1, NULL);

        // SWR Meter updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_swr_subject, update_swr_meter_observer_cb, ui_Screen1, NULL);

        // ALC Meter updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_alc_subject, update_alc_meter_observer_cb, ui_Screen1, NULL);

        // COMP Meter updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_comp_subject, update_comp_meter_observer_cb, ui_Screen1, NULL);

        // TX status updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_tx_status_subject, update_tx_status_observer_cb, ui_Screen1, NULL);

        // AGC updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_agc_subject, update_agc_observer_cb, ui_Screen1, NULL);
        // Notch filter updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_notch_subject, update_notch_observer_cb, ui_Screen1, NULL);
        // ATT updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_att_subject, update_att_observer_cb, ui_Screen1, NULL);
        // NB status updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_nb_subject, update_nb_observer_cb, ui_Screen1, NULL);
        // NR status updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_nr_subject, update_nr_observer_cb, ui_Screen1, NULL);
        // DATA mode updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_data_mode_subject, update_data_mode_observer_cb, ui_Screen1, NULL);
        // Preamp updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_preamp_subject, update_preamp_observer_cb, ui_Screen1, NULL);
        // AT status updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_at_status_subject, update_at_status_observer_cb, ui_Screen1, NULL);
        // Antenna select updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_antenna_select_subject, update_antenna_select_observer_cb, ui_Screen1, NULL);
        // Memory channel updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_memory_channel_subject, update_memory_channel_observer_cb, ui_Screen1, NULL);
        // AF Gain updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_af_gain_subject, update_af_gain_observer_cb, ui_Screen1, NULL);
        // RF Gain updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_rf_gain_subject, update_rf_gain_observer_cb, ui_Screen1, NULL);
        // Peak Hold status updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_peak_hold_enabled_subject, update_peak_hold_status_observer_cb, ui_Screen1, NULL);
        // Peak Hold duration updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_peak_hold_duration_subject, update_peak_hold_duration_observer_cb, ui_Screen1, NULL);
        // S-Meter Averaging updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_smeter_averaging_subject, update_smeter_averaging_observer_cb, ui_Screen1, NULL);
        // Transverter updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_transverter_state_subject, update_transverter_observer_cb, ui_Screen1, NULL);
        lv_subject_add_observer_obj(&radio_transverter_xo_subject, update_transverter_observer_cb, ui_Screen1, NULL);
        lv_subject_add_observer_obj(&radio_transverter_ex056_subject, update_transverter_observer_cb, ui_Screen1, NULL);
        lv_subject_add_observer_obj(&radio_transverter_enabled_subject, update_transverter_enabled_observer_cb, ui_Screen1, NULL);
        // IF data updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_if_data_subject, update_if_data_observer_cb, ui_Screen1, NULL);
        // RIT/XIT status updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_rit_status_subject, update_rit_observer_cb, ui_Screen1, NULL);
        lv_subject_add_observer_obj(&radio_xit_status_subject, update_xit_observer_cb, ui_Screen1, NULL);
        // RIT/XIT frequency updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_rit_freq_subject, update_rit_freq_observer_cb, ui_Screen1, NULL);
        lv_subject_add_observer_obj(&radio_xit_freq_subject, update_rit_freq_observer_cb, ui_Screen1, NULL);
        // Split status updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_split_subject, update_split_observer_cb, ui_Screen1, NULL);
        // Processor status updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_proc_subject, update_proc_observer_cb, ui_Screen1, NULL);
        // SH (High-Cut) filter updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_sh_filter_subject, update_sh_filter_observer_cb, ui_Screen1, NULL);
        // SL (Low-Cut) filter updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_sl_filter_subject, update_sl_filter_observer_cb, ui_Screen1, NULL);
        // CW Filter Width updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_cw_bandwidth_subject, update_cw_filter_width_observer_cb, ui_Screen1, NULL);
        // XI data updates (LVGL 9 observer only)
        lv_subject_add_observer_obj(&radio_xi_data_subject, update_xi_data_observer_cb, ui_Screen1, NULL);
        // Actual SWR Float updates (LVGL 9 observer only)
#if LV_USE_FLOAT
        lv_subject_add_observer_obj(&radio_actual_swr_float_subject, update_actual_swr_float_observer_cb, ui_Screen1, NULL);
#endif

        // Peak decay timer is now created/deleted dynamically in update_peak_hold_status_cb

        // Initialize CAT activity timestamp and start UI-based check timer
        ui_last_cat_activity_time = 0; // Start as if no data received yet, label will show "I"

        if (ui_cat_activity_check_timer == NULL) {
            ui_cat_activity_check_timer = lv_timer_create(ui_cat_activity_check_timer_cb, 1000, NULL); // Check every 1 second
            if (ui_cat_activity_check_timer) {
                lv_timer_set_repeat_count(ui_cat_activity_check_timer, -1); // Repeat indefinitely
                ESP_LOGI("UI_Screen1", "UI CAT activity check timer created.");
            } else {
                ESP_LOGE("UI_Screen1", "Failed to create ui_cat_activity_check_timer");
            }
        }
    }

    // Initialize power/carrier popup for RRC panel integration
    ui_power_popup_init(ui_Screen1);
}

void ui_Screen1_screen_destroy(void) {
    // Cleanup power popup
    ui_power_popup_cleanup();

    // Explicitly delete timers before deleting the screen object
    if (peak_decay_timer != NULL) {
        lv_timer_del(peak_decay_timer);
        peak_decay_timer = NULL;
        ESP_LOGI("UI_Screen1", "Peak decay timer deleted in screen_destroy.");
    }
    if (ui_cat_activity_check_timer != NULL) {
        lv_timer_del(ui_cat_activity_check_timer);
        ui_cat_activity_check_timer = NULL;
        ESP_LOGI("UI_Screen1", "UI CAT activity check timer deleted in screen_destroy.");
    }

    // LVGL handles deletion of child objects when ui_Screen1 is deleted.
    if (ui_Screen1 != NULL) {
        lv_obj_delete(ui_Screen1); // This will trigger screen1_del_cb if registered
    }


    ui_SMeterSegmentsContainer = NULL;
    ui_SwrMeterSegmentsContainer = NULL;
    ui_AlcMeterSegmentsContainer = NULL;

    ui_Screen1 = NULL;
    ui_SignalPanel = NULL;
    ui_SMeterLabel = NULL;
    ui_Switch1 = NULL;
    ui_SwrMeterLabel = NULL;
    // ui_SwrTextLabel = NULL; // Removed
    ui_SMeterLabelsContainer = NULL;
    for (int i = 0; i < 8; i++) {
        ui_SMeterTickLabels[i] = NULL;
    }

    ui_SwrMeterLabelsContainer = NULL;

    for (int i = 0; i < 5; i++) {
        ui_SwrMeterTickLabels[i] = NULL;
    }

    ui_AlcLabel = NULL;
    ui_CompMeterSegmentsContainer = NULL;
    for (int i = 0; i < 15; i++) {
        ui_CompMeterSegments[i] = NULL;
    }
    ui_CompLabel = NULL;
    ui_AfGainBar = NULL;
    ui_AfGainLabel = NULL;
    ui_RfGainLabel = NULL;
    ui_RfGainBar = NULL;
    ui_VfoAValue = NULL;
    ui_ModeLabel = NULL;
    ui_DataModeLabel = NULL;
    ui_VfoBValue = NULL;
    ui_VfoAButtonBackground = NULL;
    ui_VfoALabel = NULL;
    ui_VfoBButtonBackground = NULL;
    ui_VfoBLabel = NULL;
    ui_AntennaSelectContainer = NULL; // Nullify the new container
    ui_AntSymbolLabel = NULL; // Nullify the symbol button
    ui_AntNumIndicatorContainer = NULL; // Nullify the number indicator container
    ui_Ant1Label = NULL;
    ui_Ant2Label = NULL;
    ui_UtcTime = NULL;
    ui_PwrLabel = NULL;
    ui_PwrLabelsContainer = NULL;

    for (int i = 0; i < 5; i++) {
        ui_PwrTickLabels[i] = NULL;
    }

    ui_IfFilter = NULL;
    ui_IfFilterALabel = NULL;
    ui_IfFilterBLabel = NULL;
    ui_RxTxLabel = NULL;
    ui_PreAmpButton = NULL;
    ui_PreAmpButtonLabel = NULL;
    ui_AttButton = NULL;
    ui_AttButtonLabel = NULL;
    ui_AtTuneButton = NULL;
    ui_AtTuneButtonLabel = NULL;
    ui_ProcButton = NULL;
    ui_ProcButtonLabel = NULL;
    ui_IncreaseSwrButton = NULL;
    ui_IncreaseSwrLabel = NULL;
    ui_DecreaseSwrButton = NULL;
    ui_DecreaseSwrLabel = NULL;
    ui_IncreaseSMeterButton = NULL;
    ui_IncreaseSMeterLabel = NULL;
    ui_DecreaseSMeterButton = NULL;
    ui_DecreaseSMeterLabel = NULL;
    ui_SplitButton = NULL;
    ui_SplitButtonLabel = NULL;
    ui_LeftButtonColumn = NULL; // Nullify the new column container pointer
    ui_NrButton = NULL;
    ui_NrButtonLabel = NULL;
    ui_XvtrLabel = NULL;
    ui_AgcLabel = NULL;
    ui_NotchLabel = NULL;
    ui_RitContainer = NULL;
    ui_RitLabel = NULL;
    ui_RitValue = NULL;
    ui_XitContainer = NULL;
    ui_XitLabel = NULL;
    ui_XitValue = NULL;
    ui_NbButton = NULL;
    ui_NbButtonLabel = NULL;
    ui_DebugMode = NULL;
    ui_DebugModeButtonLabel = NULL;
    ui_SettingsButton = NULL;
    ui_SettingsButtonLabel = NULL;
    ui_FilterUsbContainer = NULL;
    ui_CwFilterModeGlyph = NULL; // Nullify the new glyph label pointer
}
